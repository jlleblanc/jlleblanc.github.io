<?xml version="1.0" encoding="utf-8"?>
<!-- generator="Joomla! 1.5 - Open Source Content Management" -->
<feed xmlns="http://www.w3.org/2005/Atom"  xml:lang="en-gb">
	<title type="text">tutorials</title>
	<subtitle type="text">i like code.</subtitle>
	<link rel="alternate" type="text/html" href="http://jlleblanc.com"/>
	<id>http://jlleblanc.com/tutorials</id>
	<updated>2013-06-03T01:43:45Z</updated>
	<generator uri="http://joomla.org" version="1.5">Joomla! 1.5 - Open Source Content Management</generator>
<link rel="self" type="application/atom+xml" href="http://jlleblanc.com/tutorials?format=feed&amp;type=atom" />
	<entry>
		<title>JUser tutorial for Joomla! 1.5</title>
		<link rel="alternate" type="text/html" href="http://jlleblanc.com/tutorials/48-juser-tutorial-for-joomla-15"/>
		<published>2007-09-29T19:38:18Z</published>
		<updated>2007-09-29T19:38:18Z</updated>
		<id>http://jlleblanc.com/tutorials/48-juser-tutorial-for-joomla-15</id>
		<summary type="html">&lt;p&gt;For every request in Joomla!, there is one user. Information about this user is readily available through the Joomla! framework in the form of an object. To get this object, use the following member function of JFactory:&lt;/p&gt;


&lt;pre&gt;
	$user =&amp;amp; JFactory::getUser();
&lt;/pre&gt;

&lt;p&gt;Getting a reference through getUser() ensures that only one user object is created during any one Joomla! request, saving on memory and processing time. Most of the information about the user is available through public member variables of the user object. This code displays the current user's name, email, user name, user type, and group id:&lt;/p&gt;

&lt;pre&gt;
	echo &amp;quot;&amp;lt;p&amp;gt;Your name is {$user-&amp;gt;name}, your email is {$user-&amp;gt;email}, and your username is {$user-&amp;gt;username}&amp;lt;/p&amp;gt;&amp;quot;;
	echo &amp;quot;&amp;lt;p&amp;gt;Your usertype is {$user-&amp;gt;usertype} which has a group id of {$user-&amp;gt;gid}.&amp;lt;/p&amp;gt;&amp;quot;;
&lt;/pre&gt;

&lt;p&gt;These are the relevant member variables automatically generated on a call to getUser():&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;id - The unique, numerical user id. Use this when referencing the user record in other database tables.&lt;/li&gt;
&lt;li&gt;name - The name of the user. (e.g. Vint Cerf)&lt;/li&gt;
&lt;li&gt;username - The login/screen name of the user. (e.g. shmuffin1979)&lt;/li&gt;
&lt;li&gt;email - The email address of the user. (e.g. crashoverride@hackers.com)&lt;/li&gt;
&lt;li&gt;password - The encrypted version of the user's password&lt;/li&gt;
&lt;li&gt;password_clear - Set to the user's password only when it is being changed. Otherwise, remains blank.&lt;/li&gt;
&lt;li&gt;usertype - The role of the user within Joomla!. (Super Administrator, Editor, etc...)&lt;/li&gt;
&lt;li&gt;gid - Set to the user's group id, which corresponds to the usertype.&lt;/li&gt;
&lt;li&gt;block - Set to '1' when the user is set to 'blocked' in Joomla!.&lt;/li&gt;
&lt;li&gt;registerDate - Set to the date when the user was first registered.&lt;/li&gt;
&lt;li&gt;lastvisitDate - Set to the date the user last visited the site.&lt;/li&gt;
&lt;li&gt;guest - If the user is not logged in, this variable will be set to '1'. The other variables will be unset or default values.&lt;/li&gt;
&lt;/ul&gt;
	
&lt;p&gt;In addition to the member variables (which are stored in the database in columns), there are parameters for the user that hold preferences. To get one of these parameters, call the getParam() member function of the user object, passing in the name of the parameter you want along with a default value in case it is blank.&lt;/p&gt;

&lt;pre&gt;
	$user =&amp;amp; JFactory::getUser();
	$language = $user-&amp;gt;getParam(&amp;apos;language&amp;apos;, &amp;apos;the default&amp;apos;);
	
	echo &amp;quot;&amp;lt;p&amp;gt;Your language is set to {$language}.&amp;lt;/p&amp;gt;&amp;quot;;
&lt;/pre&gt;

&lt;p&gt;Frequently, you will just want to make sure the user is logged in before continuing. The 'guest' member function will be set to '1' when the current user is not logged in. When the user is authenticated, 'guest' will be set to '0'.&lt;/p&gt;

&lt;pre&gt;
	$user =&amp;amp; JFactory::getUser();
	
	if ($user-&amp;gt;guest) {
		echo &amp;quot;&amp;lt;p&amp;gt;You must login to see the content. I want your email address.&amp;lt;/p&amp;gt;&amp;quot;;
	} else {
		?&amp;gt;
		
		&amp;lt;h1&amp;gt;Impromptu leftovers salad that goes well with fish&amp;lt;/h1&amp;gt;
		&amp;lt;ul&amp;gt;
			&amp;lt;li&amp;gt;1/2 cup chopped celery&amp;lt;/li&amp;gt;
			&amp;lt;li&amp;gt;1/4 cup raisins&amp;lt;/li&amp;gt;
			&amp;lt;li&amp;gt;1 teaspoon Extra Virgin Olive Oil&amp;lt;/li&amp;gt;
			&amp;lt;li&amp;gt;2 tablespoons of faux Thai lemongrass marinade&amp;lt;/li&amp;gt;
			&amp;lt;li&amp;gt;1/4 cup shredded fresh basil&amp;lt;/li&amp;gt;
			&amp;lt;li&amp;gt;Sprinkling of dill weed&amp;lt;/li&amp;gt;
			&amp;lt;li&amp;gt;Big pinch of kosher salt&amp;lt;/li&amp;gt;
			&amp;lt;li&amp;gt;Several lettuce leaves (to taste)&amp;lt;/li&amp;gt;
		&amp;lt;/ul&amp;gt;
		
		&amp;lt;p&amp;gt;Wash the lettuce and basil because there&amp;apos;s no telling who touched it before you did,
even if the package says &amp;quot;prewashed.&amp;quot;
Put them in a bowl; preferably a hand-crafted salad bowl,
but a metallic measuring bowl will also do.
Get out a much smaller bowl and swish around all of the remaining ingredients.
Actually, if you don&amp;apos;t want to dirty up a perfectly good and clean bowl,
you can probably just use the first bowl for this step
and dump the greens on top. Toss irregularly. Consume promptly.
Serves two, unless somebody eats a smaller portion.&amp;lt;/p&amp;gt;
		&amp;lt;?php
	}
&lt;/pre&gt;

&lt;p&gt;Not all authenticated users are given equal rights. For instance, a Super Administrator may be able to edit anyone's content, while a Publisher may only be able to edit their own. The authorize() member function can be used to determine if the current user has permission to do a certain task. The first parameter is used to identify which component or function we wish to authenticate against. The second represents the task. The third and fourth are optional; they further break the permissions down into record types and ownership respectively.&lt;/p&gt;

&lt;p&gt;In Joomla! 1.5, the rights for all of the core components are stored in libraries/joomla/user/authorization.php. These are available to all extensions wherever authentication is required. If the permission scheme of the Content component suits your extension's needs, you can use code similar to the following to determine what functions to give to a specific user.&lt;/p&gt;

&lt;pre&gt;
	$user =&amp;amp; JFactory::getUser();
	
	if ($user-&amp;gt;authorize(&amp;apos;com_content&amp;apos;, &amp;apos;edit&amp;apos;, &amp;apos;content&amp;apos;, &amp;apos;all&amp;apos;)) {
		echo &amp;quot;&amp;lt;p&amp;gt;You may edit all content.&amp;lt;/p&amp;gt;&amp;quot;;
	} else {
		echo &amp;quot;&amp;lt;p&amp;gt;You may not edit all content.&amp;lt;/p&amp;gt;&amp;quot;;
	}
	
	if ($user-&amp;gt;authorize(&amp;apos;com_content&amp;apos;, &amp;apos;publish&amp;apos;, &amp;apos;content&amp;apos;, &amp;apos;own&amp;apos;)) {
		echo &amp;quot;&amp;lt;p&amp;gt;You may publish your own content.&amp;lt;/p&amp;gt;&amp;quot;;
	} else {
		echo &amp;quot;&amp;lt;p&amp;gt;You may not publish your own content.&amp;lt;/p&amp;gt;&amp;quot;;
	}
&lt;/pre&gt;

&lt;p&gt;The permissions for core functions may not be suitable for your extension. If this is the case, you can create your own permissions. You will probably want to add this code in a place where it will always be executed, such as the beginning of the component you are building or in a systemwide plugin. First, you need to get an authorization object using the getACL() member function of JFactory. This works like getUser() in that it only creates one authorization object during any particular Joomla! request. Once you have this object, call the addACL() member function to add permissions. Pass in the name of your component or function, the task name, the string 'users', and the user type (in lowercase) respectively. If you want to also define record sets and ownership, pass those in as an additional two parameters.&lt;/p&gt;

&lt;p&gt;Note that in Joomla! 1.5, permissions are not inherited. For example, if you give an Administrator the right to edit content, Super Administrators do not automatically get this right; you must grant it separately.&lt;/p&gt;

&lt;pre&gt;
	$auth =&amp;amp; JFactory::getACL();
	
	$auth-&amp;gt;addACL(&amp;apos;com_userinfo15&amp;apos;, &amp;apos;persuade&amp;apos;, &amp;apos;users&amp;apos;, &amp;apos;super administrator&amp;apos;);
	$auth-&amp;gt;addACL(&amp;apos;com_userinfo15&amp;apos;, &amp;apos;persuade&amp;apos;, &amp;apos;users&amp;apos;, &amp;apos;administrator&amp;apos;);
	$auth-&amp;gt;addACL(&amp;apos;com_userinfo15&amp;apos;, &amp;apos;persuade&amp;apos;, &amp;apos;users&amp;apos;, &amp;apos;manager&amp;apos;);

	$user =&amp;amp; JFactory::getUser();
	
	if ($user-&amp;gt;authorize(&amp;apos;com_userinfo15&amp;apos;, &amp;apos;persuade&amp;apos;)) {
		echo &amp;quot;&amp;lt;p&amp;gt;You may persuade the system to do what you wish.&amp;lt;/p&amp;gt;&amp;quot;;
	} else {
		echo &amp;quot;&amp;lt;p&amp;gt;You are not very persuasive.&amp;lt;/p&amp;gt;&amp;quot;;
	}
&lt;/pre&gt;

&lt;p&gt;Information about the current user is readily available in any part of your Joomla! extension. You need only fetch the object and access the member variables. You can authorize the user against the core permissions set, or create your own to suit your needs.&lt;/p&gt;

&lt;p&gt;
An installable component featuring these code snippets is available for download &lt;a href=&quot;http://jlleblanc.com/com_userinfo15.zip&quot;&gt;here&lt;/a&gt;. Log into the frontend of your site and go to index.php?option=com_userinfo15 to see them in action. Log in with different users to see how the behavior changes. Access it as an unauthenticated user as well to see the difference.
&lt;/p&gt;
</summary>
		<content type="html">&lt;p&gt;For every request in Joomla!, there is one user. Information about this user is readily available through the Joomla! framework in the form of an object. To get this object, use the following member function of JFactory:&lt;/p&gt;


&lt;pre&gt;
	$user =&amp;amp; JFactory::getUser();
&lt;/pre&gt;

&lt;p&gt;Getting a reference through getUser() ensures that only one user object is created during any one Joomla! request, saving on memory and processing time. Most of the information about the user is available through public member variables of the user object. This code displays the current user's name, email, user name, user type, and group id:&lt;/p&gt;

&lt;pre&gt;
	echo &amp;quot;&amp;lt;p&amp;gt;Your name is {$user-&amp;gt;name}, your email is {$user-&amp;gt;email}, and your username is {$user-&amp;gt;username}&amp;lt;/p&amp;gt;&amp;quot;;
	echo &amp;quot;&amp;lt;p&amp;gt;Your usertype is {$user-&amp;gt;usertype} which has a group id of {$user-&amp;gt;gid}.&amp;lt;/p&amp;gt;&amp;quot;;
&lt;/pre&gt;

&lt;p&gt;These are the relevant member variables automatically generated on a call to getUser():&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;id - The unique, numerical user id. Use this when referencing the user record in other database tables.&lt;/li&gt;
&lt;li&gt;name - The name of the user. (e.g. Vint Cerf)&lt;/li&gt;
&lt;li&gt;username - The login/screen name of the user. (e.g. shmuffin1979)&lt;/li&gt;
&lt;li&gt;email - The email address of the user. (e.g. crashoverride@hackers.com)&lt;/li&gt;
&lt;li&gt;password - The encrypted version of the user's password&lt;/li&gt;
&lt;li&gt;password_clear - Set to the user's password only when it is being changed. Otherwise, remains blank.&lt;/li&gt;
&lt;li&gt;usertype - The role of the user within Joomla!. (Super Administrator, Editor, etc...)&lt;/li&gt;
&lt;li&gt;gid - Set to the user's group id, which corresponds to the usertype.&lt;/li&gt;
&lt;li&gt;block - Set to '1' when the user is set to 'blocked' in Joomla!.&lt;/li&gt;
&lt;li&gt;registerDate - Set to the date when the user was first registered.&lt;/li&gt;
&lt;li&gt;lastvisitDate - Set to the date the user last visited the site.&lt;/li&gt;
&lt;li&gt;guest - If the user is not logged in, this variable will be set to '1'. The other variables will be unset or default values.&lt;/li&gt;
&lt;/ul&gt;
	
&lt;p&gt;In addition to the member variables (which are stored in the database in columns), there are parameters for the user that hold preferences. To get one of these parameters, call the getParam() member function of the user object, passing in the name of the parameter you want along with a default value in case it is blank.&lt;/p&gt;

&lt;pre&gt;
	$user =&amp;amp; JFactory::getUser();
	$language = $user-&amp;gt;getParam(&amp;apos;language&amp;apos;, &amp;apos;the default&amp;apos;);
	
	echo &amp;quot;&amp;lt;p&amp;gt;Your language is set to {$language}.&amp;lt;/p&amp;gt;&amp;quot;;
&lt;/pre&gt;

&lt;p&gt;Frequently, you will just want to make sure the user is logged in before continuing. The 'guest' member function will be set to '1' when the current user is not logged in. When the user is authenticated, 'guest' will be set to '0'.&lt;/p&gt;

&lt;pre&gt;
	$user =&amp;amp; JFactory::getUser();
	
	if ($user-&amp;gt;guest) {
		echo &amp;quot;&amp;lt;p&amp;gt;You must login to see the content. I want your email address.&amp;lt;/p&amp;gt;&amp;quot;;
	} else {
		?&amp;gt;
		
		&amp;lt;h1&amp;gt;Impromptu leftovers salad that goes well with fish&amp;lt;/h1&amp;gt;
		&amp;lt;ul&amp;gt;
			&amp;lt;li&amp;gt;1/2 cup chopped celery&amp;lt;/li&amp;gt;
			&amp;lt;li&amp;gt;1/4 cup raisins&amp;lt;/li&amp;gt;
			&amp;lt;li&amp;gt;1 teaspoon Extra Virgin Olive Oil&amp;lt;/li&amp;gt;
			&amp;lt;li&amp;gt;2 tablespoons of faux Thai lemongrass marinade&amp;lt;/li&amp;gt;
			&amp;lt;li&amp;gt;1/4 cup shredded fresh basil&amp;lt;/li&amp;gt;
			&amp;lt;li&amp;gt;Sprinkling of dill weed&amp;lt;/li&amp;gt;
			&amp;lt;li&amp;gt;Big pinch of kosher salt&amp;lt;/li&amp;gt;
			&amp;lt;li&amp;gt;Several lettuce leaves (to taste)&amp;lt;/li&amp;gt;
		&amp;lt;/ul&amp;gt;
		
		&amp;lt;p&amp;gt;Wash the lettuce and basil because there&amp;apos;s no telling who touched it before you did,
even if the package says &amp;quot;prewashed.&amp;quot;
Put them in a bowl; preferably a hand-crafted salad bowl,
but a metallic measuring bowl will also do.
Get out a much smaller bowl and swish around all of the remaining ingredients.
Actually, if you don&amp;apos;t want to dirty up a perfectly good and clean bowl,
you can probably just use the first bowl for this step
and dump the greens on top. Toss irregularly. Consume promptly.
Serves two, unless somebody eats a smaller portion.&amp;lt;/p&amp;gt;
		&amp;lt;?php
	}
&lt;/pre&gt;

&lt;p&gt;Not all authenticated users are given equal rights. For instance, a Super Administrator may be able to edit anyone's content, while a Publisher may only be able to edit their own. The authorize() member function can be used to determine if the current user has permission to do a certain task. The first parameter is used to identify which component or function we wish to authenticate against. The second represents the task. The third and fourth are optional; they further break the permissions down into record types and ownership respectively.&lt;/p&gt;

&lt;p&gt;In Joomla! 1.5, the rights for all of the core components are stored in libraries/joomla/user/authorization.php. These are available to all extensions wherever authentication is required. If the permission scheme of the Content component suits your extension's needs, you can use code similar to the following to determine what functions to give to a specific user.&lt;/p&gt;

&lt;pre&gt;
	$user =&amp;amp; JFactory::getUser();
	
	if ($user-&amp;gt;authorize(&amp;apos;com_content&amp;apos;, &amp;apos;edit&amp;apos;, &amp;apos;content&amp;apos;, &amp;apos;all&amp;apos;)) {
		echo &amp;quot;&amp;lt;p&amp;gt;You may edit all content.&amp;lt;/p&amp;gt;&amp;quot;;
	} else {
		echo &amp;quot;&amp;lt;p&amp;gt;You may not edit all content.&amp;lt;/p&amp;gt;&amp;quot;;
	}
	
	if ($user-&amp;gt;authorize(&amp;apos;com_content&amp;apos;, &amp;apos;publish&amp;apos;, &amp;apos;content&amp;apos;, &amp;apos;own&amp;apos;)) {
		echo &amp;quot;&amp;lt;p&amp;gt;You may publish your own content.&amp;lt;/p&amp;gt;&amp;quot;;
	} else {
		echo &amp;quot;&amp;lt;p&amp;gt;You may not publish your own content.&amp;lt;/p&amp;gt;&amp;quot;;
	}
&lt;/pre&gt;

&lt;p&gt;The permissions for core functions may not be suitable for your extension. If this is the case, you can create your own permissions. You will probably want to add this code in a place where it will always be executed, such as the beginning of the component you are building or in a systemwide plugin. First, you need to get an authorization object using the getACL() member function of JFactory. This works like getUser() in that it only creates one authorization object during any particular Joomla! request. Once you have this object, call the addACL() member function to add permissions. Pass in the name of your component or function, the task name, the string 'users', and the user type (in lowercase) respectively. If you want to also define record sets and ownership, pass those in as an additional two parameters.&lt;/p&gt;

&lt;p&gt;Note that in Joomla! 1.5, permissions are not inherited. For example, if you give an Administrator the right to edit content, Super Administrators do not automatically get this right; you must grant it separately.&lt;/p&gt;

&lt;pre&gt;
	$auth =&amp;amp; JFactory::getACL();
	
	$auth-&amp;gt;addACL(&amp;apos;com_userinfo15&amp;apos;, &amp;apos;persuade&amp;apos;, &amp;apos;users&amp;apos;, &amp;apos;super administrator&amp;apos;);
	$auth-&amp;gt;addACL(&amp;apos;com_userinfo15&amp;apos;, &amp;apos;persuade&amp;apos;, &amp;apos;users&amp;apos;, &amp;apos;administrator&amp;apos;);
	$auth-&amp;gt;addACL(&amp;apos;com_userinfo15&amp;apos;, &amp;apos;persuade&amp;apos;, &amp;apos;users&amp;apos;, &amp;apos;manager&amp;apos;);

	$user =&amp;amp; JFactory::getUser();
	
	if ($user-&amp;gt;authorize(&amp;apos;com_userinfo15&amp;apos;, &amp;apos;persuade&amp;apos;)) {
		echo &amp;quot;&amp;lt;p&amp;gt;You may persuade the system to do what you wish.&amp;lt;/p&amp;gt;&amp;quot;;
	} else {
		echo &amp;quot;&amp;lt;p&amp;gt;You are not very persuasive.&amp;lt;/p&amp;gt;&amp;quot;;
	}
&lt;/pre&gt;

&lt;p&gt;Information about the current user is readily available in any part of your Joomla! extension. You need only fetch the object and access the member variables. You can authorize the user against the core permissions set, or create your own to suit your needs.&lt;/p&gt;

&lt;p&gt;
An installable component featuring these code snippets is available for download &lt;a href=&quot;http://jlleblanc.com/com_userinfo15.zip&quot;&gt;here&lt;/a&gt;. Log into the frontend of your site and go to index.php?option=com_userinfo15 to see them in action. Log in with different users to see how the behavior changes. Access it as an unauthenticated user as well to see the difference.
&lt;/p&gt;
</content>
	</entry>
	<entry>
		<title>Daily Message Component Tutorial for Joomla 1.5</title>
		<link rel="alternate" type="text/html" href="http://jlleblanc.com/tutorials/47-daily-message-component-tutorial-for-joomla-15"/>
		<published>2007-08-19T20:44:52Z</published>
		<updated>2007-08-19T20:44:52Z</updated>
		<id>http://jlleblanc.com/tutorials/47-daily-message-component-tutorial-for-joomla-15</id>
		<author>
			<name>Joe LeBlanc</name>
		<email>joe@jlleblanc.com</email>
		</author>
		<summary type="html">&lt;p class=&quot;online&quot;&gt;This tutorial is designed to help you build a complete component with a backend and frontend. After reading the tutorial, you should understand how some of the core classes and functions work so that you can use them in your own components. A full, ready to install copy of the component can be &lt;a href=&quot;http://jlleblanc.com/com_dailymessage15.zip&quot;&gt;downloaded here&lt;/a&gt;. This tutorial is designed for Joomla 1.5; &lt;a href=&quot;http://jlleblanc.com/index.php?option=com_content&amp;amp;task=view&amp;amp;id=9&quot;&gt;a version for 1.0 can be found here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Different people will understand the functionality of Joomla components in different ways. Developers with significant previous PHP experience may wish to start with dailymessage.php (the file generating the frontend display) and admin.dailymessage.php (generates the backend display). Others will want to start with the XML document which maps out every code source, image, and SQL query.&lt;/p&gt;
&lt;h3 id=&quot;dailymessage&quot; class=&quot;dailymessage&quot;&gt;dailymessage.php&lt;/h3&gt;
&lt;div class=&quot;source&quot;&gt;
&lt;p&gt;When you click on a link to the Daily Message component from the frontend, the file dailymessage.php in the /components/com_dailymessage folder is executed. You can add any valid PHP code you wish from here, but there are some security measures you should take even if you are not going to be using Joomla!'s libraries.&lt;/p&gt;
&lt;pre&gt;&amp;lt;?php&lt;br /&gt;&lt;br /&gt;defined('_JEXEC') or die();&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;As with every file of source code in Joomla!, we start with an opening PHP tag. We also use the defined() call to check to make sure that Joomla! is requesting dailymessage.php and that it is not being requested directly. If it is being requested directly, we quit right away.&lt;/p&gt;
&lt;pre&gt;$db =&amp;amp; JFactory::getDBO();&lt;br /&gt;&lt;br /&gt;$db-&amp;gt;setQuery(&quot;SELECT * FROM #__dailymessage WHERE published = 1 ORDER BY date&quot;);&lt;br /&gt;$rows = $db-&amp;gt;loadObjectList();&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The first thing we want to do is to grab all of the published messages from the database so that we can prepare them for display. To do this, we first get a reference to the database Joomla! is currently connected to. Next, we pass our query into the setQuery() member function. The prefix #__ will be converted to jos_ (or whatever database prefix you chose for your installation) when the query is actually run. To get the rows out, we call the loadObjectList() function which returns an array of row objects. This array gets stored in $rows.&lt;/p&gt;
&lt;pre&gt;list($begin, $end) = getMessageFormat();&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Our component has some configuration that allows the administrator to add bold, underline, and italicize tags around each message. The getMessageFormat() function (defined in this file below) returns an array with the opening and closing tags. We use PHP's list() language construct to extract the two array elements into $begin and $end.&lt;/p&gt;
&lt;pre&gt;echo '&amp;lt;ul&amp;gt;';&lt;br /&gt;&lt;br /&gt;foreach ($rows as $row) {&lt;br /&gt;	echo '&amp;lt;li&amp;gt;' . JHTML::date($row-&amp;gt;date) . ' ' . $begin . $row-&amp;gt;message . $end . '&amp;lt;/li&amp;gt;';&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;echo '&amp;lt;/ul&amp;gt;';&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;To list the daily messages, we start by outputting an opening unordered list tag. Then we cycle over each record in the $rows array and output a list item for each. The JHTML::date() function formats the value of $row-&amp;gt;date according to the preferences set in Joomla!. The beginning formatting tags are output, followed by the message in $row-&amp;gt;message, followed by the ending formatting tags.&lt;/p&gt;
&lt;pre&gt;function getMessageFormat()&lt;br /&gt;{&lt;br /&gt;	$params =&amp;amp; JComponentHelper::getParams('com_dailymessage');&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;In Joomla!, menu items control the appearance and behavior of a page, as well as the configuration for a component. This function is designed to get the configuration for the current menu item and return an appropriate set of formatting tags. The getParams() member function of JComponentHelper returns a parameters object when we pass in the name of a component (in this case, com_dailymessage). Since we are loading com_dailymessage, we get the parameters set for the current menu item and store them in $params.&lt;/p&gt;
&lt;pre&gt;	$italic = $params-&amp;gt;get('italic', false);&lt;br /&gt;	$bold = $params-&amp;gt;get('bold', false);&lt;br /&gt;	$underline = $params-&amp;gt;get('underline', false);&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The get() member function of the $params object returns the values for parameter names you pass in. In addition to the names, you can specify a default value for your parameters (in our case, false).&lt;/p&gt;
&lt;pre&gt;	$begin = '';&lt;br /&gt;	$end = '';&lt;br /&gt;&lt;br /&gt;	if ($italic) {&lt;br /&gt;		$begin .= '&amp;lt;i&amp;gt;';&lt;br /&gt;		$end = '&amp;lt;/i&amp;gt;' . $end;&lt;br /&gt;	}&lt;br /&gt;&lt;br /&gt;	if ($bold) {&lt;br /&gt;		$begin .= '&amp;lt;b&amp;gt;';&lt;br /&gt;		$end = '&amp;lt;/b&amp;gt;' . $end;&lt;br /&gt;	}&lt;br /&gt;&lt;br /&gt;	if ($underline) {&lt;br /&gt;		$begin .= '&amp;lt;u&amp;gt;';&lt;br /&gt;		$end = '&amp;lt;/u&amp;gt;' . $end;&lt;br /&gt;	}&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Before building our formatting tags, we set $begin and $end as blank strings. We then test each of the variables we just set using $params-&amp;gt;get(). If they are set to something other than false or 0, we add the appropriate tags to the $begin and $end strings; the $begin tags are appended, while the $end tags are prepended.&lt;/p&gt;
&lt;pre&gt;	$format = array($begin, $end);&lt;br /&gt;&lt;br /&gt;	return $format;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we set $format to the contents of $begin and $end with a space between, then return $format.&lt;/p&gt;
&lt;pre&gt;}&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;admindailymessage&quot; class=&quot;dailymessage&quot;&gt;admin.dailymessage.php&lt;/h3&gt;
&lt;div class=&quot;source&quot;&gt;
&lt;p&gt;When you go to the backend and choose Daily Message from the Components menu, the file admin.dailymessage.php in the /administrator/components/com_dailymessage folder is executed. This file can contain any PHP code you desire, but you are probably more interested in generating screens that look like the ones in other components.&lt;/p&gt;
&lt;pre&gt;&amp;lt;?php&lt;br /&gt;&lt;br /&gt;defined('_JEXEC') or die();&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;We begin with an opening &amp;lt;?php tag and a call to defined(). This particular call makes sure that the code is being executed from within Joomla!. If not, PHP will stop right away. This is to prevent people from running your code outside of Joomla!. Without this line, someone would be able to pull up http://www.yoursite.com/administrator/components/com_dailymessage/admin.dailymessage.php without having to first log into the backend, leaving them free to use the functions you intended only for admins. For this reason, place this line at the top of each one of your files of code.&lt;/p&gt;
&lt;pre&gt;JTable::addIncludePath(JPATH_COMPONENT.DS.'tables');&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;This call to the addIncludePath() member function of JTable pulls in all of the files in our directory of database table classes. Any classes contained in these files will be available through JTable. The JPATH_COMPONENT constant is automatically defined by Joomla! to point to the current directory where our component script is running. A directory separator appropriate to the host operating system is defined in DS. Therefore, if our installation of Joomla! was hosted at /var/www on our host, the resulting string in the call to addIncludePath() would be /var/www/administrator/components/com_dailymessage/tables.&lt;/p&gt;
&lt;pre&gt;require_once(JPATH_COMPONENT.DS.'controller.php');&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The logic flow through our backend component will be handled through a controller. Our controller makes it simple to add new functions to the component in an organized, predictable way.&lt;/p&gt;
&lt;pre&gt;$controller = new DailyMessageController();&lt;br /&gt;$controller-&amp;gt;registerDefaultTask('listMessages');&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;To get the controller started, we assign a new instance of DailyMessageController to $controller. Next, we use the registerDefaultTask() member function to specify which function should be executed when the user either does not choose one or tries to use one that does not exist.&lt;/p&gt;
&lt;pre&gt;$task = JRequest::getCmd('task');&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;When we pass in 'task', the getCmd() member function of JRequest will return the name of the function the user is trying to run. This can appear in the URL (http://www.yoursite.com/administrator/index.php?option=com_dailymessage&amp;amp;task=iwanttorunthistask), be included in the HTTP POST variables, or be otherwise generated by the Joomla! framework.&lt;/p&gt;
&lt;pre&gt;$controller-&amp;gt;execute($task);&lt;br /&gt;$controller-&amp;gt;redirect();&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;With the correct $task in hand, we pass it off to execute() where it is matched up to the name of a function. Finally, we call redirect(). If we executed a $task that did not result in a screen, we need to redirect the browser to another task that does.&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id=&quot;controller&quot; class=&quot;dailymessage&quot;&gt;controller.php&lt;/h3&gt;
&lt;div class=&quot;source&quot;&gt;
&lt;p&gt;This file includes a controller based on the JController base class included with Joomla!. It automates the logical flow of our component so we can concentrate on adding new functions as we need them without disturbing older ones. We pass in the task we want to run into execute() and the controller handles the rest.&lt;/p&gt;
&lt;pre&gt;&amp;lt;?php&lt;br /&gt;&lt;br /&gt;defined('_JEXEC') or die();&lt;br /&gt;&lt;br /&gt;jimport('joomla.application.component.controller');&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Once again, we begin with an opening &amp;lt;?php tag and a check to make sure that _JEXEC has been set. We also use the jimport() function to pull in the code for the JController base class. Joomla! is in the habit of keeping the code in memory to a minimum (to keep performance fast), while providing a large library of functions and classes for you to use where desired.&lt;/p&gt;
&lt;pre&gt;class DailyMessageController extends JController&lt;br /&gt;{&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;We declare our DailyMessageController class as an extension of JController. Extending this class provides ours with the registerDefaultTask(), execute(), and redirect() member functions we used in admin.dailymessage.php along with several others. All extensions of JController typically follow the convention of having a name ending in 'Controller', as ours does.&lt;/p&gt;
&lt;pre&gt;	function __construct()&lt;br /&gt;	{&lt;br /&gt;		parent::__construct();&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The __contstruct() function is called when a new DailyMessageController() is created. (The default behavior of PHP 5 does this by default where PHP 4 does not. Joomla!'s JObject base class adds this behavior to PHP 4). We call the JController constructor so that it can build an inventory of all of the tasks available.&lt;/p&gt;
&lt;pre&gt;		$this-&amp;gt;registerTask('add', 'edit');&lt;br /&gt;		$this-&amp;gt;registerTask('unpublish', 'publish');&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;There are two tasks, add and unpublish, that are almost identical in nature to other tasks present in the controller. Instead of writing entirely different functions for these with only minor changes, we use the registerTask() JController member function to tell the controller to call the edit function when we choose 'add' and the publish function when we select 'unpublish'. (While it might seem that unpublishing is the complete opposite of publishing, all we are really doing is changing a number in the database.)&lt;/p&gt;
&lt;pre&gt;	}&lt;br /&gt;&lt;br /&gt;	function save()&lt;br /&gt;	{&lt;br /&gt;		$option = JRequest::getCmd('option');&lt;br /&gt;		$this-&amp;gt;setRedirect('index.php?option=' . $option);&lt;br /&gt;	&lt;/pre&gt;
&lt;p&gt;The save() task will be adding and updating the data for our daily messages in the database. Since it will not normally generate output, we will want to redirect the user back to the main admin screen for our component when we are done saving. As we did with $task, passing 'option' into JRequest::getCmd() will return 'com_dailymessage'. (If we were to later change the name of our component to something else, say com_weeklymessage, this piece of code would return the new name instead.) The setRedirect() member function of JController specifies the URL we want to send the user to after the task is complete.&lt;/p&gt;
&lt;pre&gt;		$post = JRequest::get('post');&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The when we pass 'post' into the get() member function of JRequest, it processes and returns a cleaned copy of the variables in the $_POST array. Using get('post') instead of accessing $_POST provides us with a level of protection against malicious data.&lt;/p&gt;
&lt;pre&gt;		$row =&amp;amp; JTable::getInstance('DailyMessage', 'Table');&lt;/pre&gt;
&lt;p&gt;The getInstance() member function of JTable returns a database table object for the table where will will store our data. The name &quot;TableDailyMessage&quot; is assembled by getInstance() as the second parameter is the class name prefix and the first is the suffix.&lt;/p&gt;
&lt;pre&gt;		if (!$row-&amp;gt;bind($post)) {&lt;br /&gt;			return JError::raiseWarning(500, $row-&amp;gt;getError());&lt;br /&gt;		}&lt;br /&gt;&lt;br /&gt;		if (!$row-&amp;gt;store()) {&lt;br /&gt;			return JError::raiseWarning(500, $row-&amp;gt;getError());&lt;br /&gt;		}&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;We call two member functions of the database table object. Passing an array into bind() matches the keys and values of that array to the member variables of the database table class. Calling store() takes the member variables and executes an SQL statement for either an INSERT or UPDATE statement. If a value is provided for the table key, an UPDATE statement is used; otherwise an INSERT is generated. If either bind() or store() fails, we call the raiseWarning() member function of JError to stop the component and to dump the error to the screen so we can figure out how to fix it.&lt;/p&gt;
&lt;pre&gt;		$this-&amp;gt;setMessage('Message Saved');&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Finally, once the data has successfully made it into the database, we use JController's setMessage() member function to store a message to be displayed in the browser after the task is complete. Since the save() task does not produce any output, this message is added as a variable in the URL the browser is redirected to when the $controller-&amp;gt;redirect() function is called in controller.php.&lt;/p&gt;
&lt;pre&gt;	}&lt;br /&gt;&lt;br /&gt;	function edit()&lt;br /&gt;	{&lt;br /&gt;		$cid = JRequest::getVar('cid', array(), 'request', 'array');&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Similar to the $post variable in the save() task, we want to get an array from the HTTP request and we want Joomla! to make sure the contents are safe. The getVar() member function of JRequest works similar to get(), except that it only retrieves an element from one of the superglobal arrays ($_GET, $_POST, $_REQUEST, etc...). In this instance, we are getting the 'cid' variable. If this does not exist, we want to default to a blank array. We want Joomla! to pull this out of the $_REQUEST superglobal and want to ensure that the data is in fact an array.&lt;/p&gt;
&lt;pre&gt;		$row =&amp;amp; JTable::getInstance('DailyMessage', 'Table');&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;As in the save() task, we pull in a database table object for the table where the daily messages are stored.&lt;/p&gt;
&lt;pre&gt;		if (isset($cid[0])) {&lt;br /&gt;			$row-&amp;gt;load($cid[0]);&lt;br /&gt;		}&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Unlike the save() task, we first test to see if one of the records has been chosen by the user. The 'cid' form variable represents the checkboxes you see alongside a listing of records. If the user has checked at least one box, the ID of the first one checked will be present in $cid[0]. We then call the load() member function to get the corresponding record from the database. If no boxes have been checked, we will just have a 'blank' database table object.&lt;/p&gt;
&lt;pre&gt;		require_once(JPATH_COMPONENT.DS.'admin.dailymessage.html.php');&lt;br /&gt;		$option = JRequest::getCmd('option');&lt;br /&gt;		HTML_DailyMessage::edit($option, $row);&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Since the edit() task will be generating HTML output, we need to pull in the file with the functions that generate it: admin.dailymessage.html.php. Using JPATH_COMPONENT and DS allow us to get a path to our current directory and we just add the filename to the end. The function generating the edit form needs to know which component to point to, so we use JRequest::getCmd() to get the value of 'option'. Finally, we call HTML_DailyMessage::edit(), passing in the name of the component with the row of data (or the blank if one was not loaded) so that the form can be displayed.&lt;/p&gt;
&lt;pre&gt;	}&lt;br /&gt;&lt;br /&gt;	function remove()&lt;br /&gt;	{&lt;br /&gt;		$option = JRequest::getCmd('option');&lt;br /&gt;&lt;br /&gt;		$this-&amp;gt;setRedirect('index.php?option=' . $option);&lt;br /&gt;&lt;br /&gt;		$db	=&amp;amp; JFactory::getDBO();&lt;br /&gt;		$cid = JRequest::getVar('cid', array(), 'request', 'array');&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The remove() task looks for any IDs found in the 'cid' array and removes the corresponding daily messages from the database. Like the save() task, this task does not produce any direct output, so we capture the component name in $option and set our redirect to go back to the main component screen when the deleting is complete. We get a reference to the live database object as well as a copy of the 'cid' array from the request.&lt;/p&gt;
&lt;pre&gt;		$count = count($cid);&lt;br /&gt;&lt;br /&gt;		if ($count)&lt;br /&gt;		{&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Before attempting to remove records from the database, we first get a count of the number of IDs. If there are none, this entire block is skipped and the browser just redirects back to the main component screen (although the Javascript in the toolbar usually prevents this from happening in the first place).&lt;/p&gt;
&lt;pre&gt;			$db-&amp;gt;setQuery('DELETE FROM #__dailymessage WHERE id IN (' . implode( ',', $cid ) . ')' );&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;If the IDs are present, we create a query to delete them and pass it into the setQuery() member function of the database object. The constant #__ is automatically turned into your installation's database prefix (usually jos_) when it is run. PHP's implode() function takes our array of IDs and turns it into a comma separated string the database can understand.&lt;/p&gt;
&lt;pre&gt;			if (!$db-&amp;gt;query()) {&lt;br /&gt;				JError::raiseWarning( 500, $db-&amp;gt;getError() );&lt;br /&gt;			}&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;After the query is set, we call the database object's query() member function which executes that query. If a problem occurs, we stop processing, raise a warning, and display the error from the database for debugging.&lt;/p&gt;
&lt;pre&gt;			if ($count &amp;gt; 1) {&lt;br /&gt;				$s = 's';&lt;br /&gt;			} else {&lt;br /&gt;				$s = '';&lt;br /&gt;			}&lt;br /&gt;&lt;br /&gt;			$this-&amp;gt;setMessage('Message' . $s . ' removed');&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;If the deletion goes through with no problems, we add a message to be displayed on the main screen stating they were removed. First, we determine whether one or several records were removed and use this to properly pluralize the message. Then we call setMessage() so that the controller can add it to the redirection URL for display.&lt;/p&gt;
&lt;pre&gt;		}&lt;br /&gt;	}&lt;br /&gt;&lt;br /&gt;	function publish()&lt;br /&gt;	{&lt;br /&gt;		$option = JRequest::getCmd('option');&lt;br /&gt;&lt;br /&gt;		$this-&amp;gt;setRedirect('index.php?option=' . $option);&lt;br /&gt;&lt;br /&gt;		$cid = JRequest::getVar('cid', array(), 'request', 'array');&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The publish() task gets IDs from the 'cid' array and sets the publishing for these records. This is yet another task that does not produce any direct output, so we set our redirect to go back to the main list screen after we are done. The $cid variable gets set to the 'cid' array from the request.&lt;/p&gt;
&lt;pre&gt;		if ($this-&amp;gt;getTask() == 'publish') {&lt;br /&gt;			$publish = 1;&lt;br /&gt;		} else {&lt;br /&gt;			$publish = 0;&lt;br /&gt;		}&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The publish() task is set to handle both the 'publish' and 'unpublish' tasks. Because of this, we need to determine which task we are handling and act accordingly. The controller's getTask() member function returns this back to us value back to us. If it is equal to 'publish', we set $publish to 1, otherwise (when it is set to 'unpublish') we set $publish to 0.&lt;/p&gt;
&lt;pre&gt;		$table =&amp;amp; JTable::getInstance('DailyMessage', 'Table');&lt;br /&gt;&lt;br /&gt;		$table-&amp;gt;publish($cid, $publish);&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;After getting a database table object for the daily message table, we call JTable's publish() member function. This function takes an array of table key IDs and sets the 'publish' column of the rows with those IDs to the value of the second parameter.&lt;/p&gt;
&lt;pre&gt;		if (count($cid) &amp;gt; 1) {&lt;br /&gt;			$s = 's';&lt;br /&gt;		} else {&lt;br /&gt;			$s = '';&lt;br /&gt;		}&lt;br /&gt;&lt;br /&gt;		$action = ucfirst($this-&amp;gt;getTask()) . 'ed';&lt;br /&gt;&lt;br /&gt;		$this-&amp;gt;setMessage('Message' . $s . ' ' . $action);&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Once the publishing or unpublishing is complete, we are ready to redirect the user back to the list of messages. Before doing this, we need to assemble an appropriate message to display at the top of the screen when they land there. First, we count the number of records processed and set $s accordingly for pluralizing the word. Next, we again use the getTask() member function of the controller to get the name of the task we just published, capitalize the first letter, add 'ed' to the end, and store the result in $action. This way, $action will either say 'Published' or 'Unpublished'. Finally, we call the controller's setMessage() function to make it available on redirection.&lt;/p&gt;
&lt;pre&gt;	}&lt;br /&gt;&lt;br /&gt;	function listMessages()&lt;br /&gt;	{&lt;br /&gt;		$option = JRequest::getCmd('option');&lt;br /&gt;&lt;br /&gt;		$db	=&amp;amp; JFactory::getDBO();&lt;br /&gt;		$db-&amp;gt;setQuery(&quot;SELECT * FROM #__dailymessage&quot;);&lt;br /&gt;		$rows = $db-&amp;gt;loadObjectList();&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The listMessages() task gets all of the messages from the database, then passes these along to be turned into an admin screen where the messages are listed. First, we get the component name using JRequest::getCmd('option'), because it will be needed to build the form controlling the message list. Next, we get a reference to the current database object and use setQuery() to pass in our SELECT statement. Finally, we use the loadObjectList() member function, which returns all of the records in the database as an array of objects. Each of the objects in the $rows array represent a single row in the database table, with the column values available as public variables.&lt;/p&gt;
&lt;pre&gt;		require_once(JPATH_COMPONENT.DS.'admin.dailymessage.html.php');&lt;br /&gt;		HTML_DailyMessage::listMessages($option, $rows);&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Like the edit() task, we include admin.dailymessage.html.php so that we can call up the function for HTML output. Then we pass the current component name and the array of row objects into HTML_DailyMessage::listMessages() for display.&lt;/p&gt;
&lt;pre&gt;	}&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;admindailymessagehtml&quot; class=&quot;dailymessage&quot;&gt;admin.dailymessage.html.php&lt;/h3&gt;
&lt;div class=&quot;source&quot;&gt;
&lt;pre&gt;&amp;lt;?php&lt;br /&gt;&lt;br /&gt;defined('_JEXEC') or die();&lt;br /&gt;&lt;br /&gt;class HTML_DailyMessage&lt;br /&gt;{&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;As with the other files, we begin with our opening PHP tag, the check to make sure we are in Joomla!, and declare the HTML_DailyMessage class.&lt;/p&gt;
&lt;pre&gt;	function listMessages($option, &amp;amp;$rows)&lt;br /&gt;	{&lt;br /&gt;		HTML_DailyMessage::setAllMessagesToolbar();&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The listMessages() function takes the current component name as the first parameter, and an array of row objects as the second (using &amp;amp; to pass this array by reference to save memory). We then call the setAllMessagesToolbar() function in this same class to set up our toolbar buttons. Notice that we are not calling $this-&amp;gt;setAllMessagesToolbar(), since we are using HTML_DailyMessage statically.&lt;/p&gt;
&lt;pre&gt;		?&amp;gt;&lt;br /&gt;		&amp;lt;form action=&quot;index.php&quot; method=&quot;post&quot; name=&quot;adminForm&quot;&amp;gt;&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The form wrapping around all message record listings points to index.php (as all requests through Joomla! do) and is named 'adminForm'. Naming the form as such is very important so that the Javascript in Joomla!'s backend can interact with it.&lt;/p&gt;
&lt;pre&gt;			&amp;lt;table class=&quot;adminlist&quot;&amp;gt;&lt;br /&gt;				&amp;lt;thead&amp;gt;&lt;br /&gt;					&amp;lt;tr&amp;gt;&lt;br /&gt;					&amp;lt;th width=&quot;20&quot;&amp;gt;&lt;br /&gt;					&amp;lt;input type=&quot;checkbox&quot; name=&quot;toggle&quot; value=&quot;&quot;  onclick=&quot;checkAll(&amp;lt;?php echo count( $rows ); ?&amp;gt;);&quot; /&amp;gt;&lt;br /&gt;					&amp;lt;/th&amp;gt;&lt;br /&gt;					&amp;lt;th nowrap=&quot;nowrap&quot; class=&quot;title&quot;&amp;gt;Message&amp;lt;/th&amp;gt;&lt;br /&gt;					&amp;lt;th nowrap=&quot;nowrap&quot;&amp;gt;Date&amp;lt;/th&amp;gt;&lt;br /&gt;					&amp;lt;th nowrap=&quot;nowrap&quot;&amp;gt;Published&amp;lt;/th&amp;gt;&lt;br /&gt;					&amp;lt;/tr&amp;gt;&lt;br /&gt;				&amp;lt;/thead&amp;gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Our records are presented in a table, which is assigned the 'adminList' class. This makes the table appear with the same style as other components in the Joomla! backend. Next, we create the header row. The first header column is a checkbox that will allow the user to toggle on or off all of the records on screen at once. We give it the name 'toggle' and assign an onclick event, passing in the total number of rows being displayed on the screen.&lt;/p&gt;
&lt;pre&gt;				&amp;lt;tbody&amp;gt;&lt;br /&gt;&lt;br /&gt;					&amp;lt;?php&lt;br /&gt;&lt;br /&gt;					$k = 0;&lt;br /&gt;					for ($i=0, $n=count( $rows ); $i &amp;lt; $n; $i++) {&lt;br /&gt;						$row = &amp;amp;$rows[$i];&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;We begin our loop through the records by first setting $k to 0, which we will use to help us alternate the row styles. Next, we set our for() loop with $i starting at 0 and $n equaling the total number of rows to be displayed. Inside the loop, we set $row to a reference of the object in the array at position $i.&lt;/p&gt;
&lt;pre&gt;						$published = JHTML::_('grid.published', $row, $i );&lt;br /&gt; 						$checked = JHTML::_('grid.id', $i, $row-&amp;gt;id );&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Before outputting the row, we want to build a couple of elements so that we can essentially echo out the rest. The JHTML::_() function allows us to get commonly used HTML from the Joomla! library. To reduce the amount of code in memory, Joomla! only loads the functions for the particular HTML elements we want when we want them. To do this, we pass in the name of the element desired as the first parameter, then all of the other parameters for that element afterwards. The JHTML class does the rest, without the need to call jimport() to pull in the necessary files. For the publishing button, we pass in our $row and the current record number in $i. For the checkbox, we pass in the record number first, then the $row.&lt;/p&gt;
&lt;pre&gt;						$link = 'index.php?option=' . $option . '&amp;amp;task=edit&amp;amp;cid[]='. $row-&amp;gt;id;&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;We also build the URL for the links to messages using the component name and the id of the $row. The cid[] variable in the URL will match the form variable for the checkbox, it will all look the same to our controller.&lt;/p&gt;
&lt;pre&gt;						?&amp;gt;&lt;br /&gt;						&amp;lt;tr class=&quot;&amp;lt;?php echo &quot;row$k&quot;; ?&amp;gt;&quot;&amp;gt;&lt;br /&gt;							&amp;lt;td align=&quot;center&quot;&amp;gt;&lt;br /&gt;								&amp;lt;?php echo $checked; ?&amp;gt;&lt;br /&gt;							&amp;lt;/td&amp;gt;&lt;br /&gt;							&amp;lt;td&amp;gt;&lt;br /&gt;								&amp;lt;a href=&quot;http://jlleblanc.com/&amp;lt;?php echo $link; ?&amp;gt;&quot; title=&quot;Edit Message&quot;&amp;gt;&lt;br /&gt;									&amp;lt;?php echo $row-&amp;gt;message; ?&amp;gt;&lt;br /&gt;								&amp;lt;/a&amp;gt;&lt;br /&gt;							&amp;lt;/td&amp;gt;&lt;br /&gt;							&amp;lt;td&amp;gt;&lt;br /&gt;								&amp;lt;?php echo JHTML::date($row-&amp;gt;date); ?&amp;gt;&lt;br /&gt;							&amp;lt;/td&amp;gt;&lt;br /&gt;							&amp;lt;td align=&quot;center&quot;&amp;gt;&lt;br /&gt;								&amp;lt;?php echo $published; ?&amp;gt;&lt;br /&gt;							&amp;lt;/td&amp;gt;&lt;br /&gt;						&amp;lt;?php&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Outputting the row is straightforward. First, we start the row and assign the &amp;lt;tr&amp;gt; element with the class 'row$k', where $k is either a 1 or 0. The background of class 'row1' is slightly darker than 'row0', which creates an alternating visual effect. The checkbox and link URL are simply echoed out, as well as the publishing button. The text for the editing URL is the daily message itself, which is found in the $row object's 'message' member variable (just like the 'message' column in the database). The 'date' column in the database is in MySQL date format, which is usually not what we want to display. Passing this through JHTML::date() formats it according to the display preferences of the user.&lt;/p&gt;
&lt;pre&gt;						$k = 1 - $k;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;This line may appear a little odd, but it helps to create the alternating bar visual effect on the table. If $k is set to 0, we subtract it from 1 and end up with 1 for the next cycle through the loop. When $k is already set to 1, we subtract 1 and get back to 0. This way, the rows alternate evenly between row0 and row1.&lt;/p&gt;
&lt;pre&gt;					}&lt;br /&gt;&lt;br /&gt;					?&amp;gt;&lt;br /&gt;				&amp;lt;/tbody&amp;gt;&lt;br /&gt;			&amp;lt;/table&amp;gt;&lt;br /&gt;&lt;br /&gt;			&amp;lt;input type=&quot;hidden&quot; name=&quot;option&quot; value=&quot;&amp;lt;?php echo $option; ?&amp;gt;&quot; /&amp;gt;&lt;br /&gt;			&amp;lt;input type=&quot;hidden&quot; name=&quot;task&quot; value=&quot;&quot; /&amp;gt;&lt;br /&gt;			&amp;lt;input type=&quot;hidden&quot; name=&quot;boxchecked&quot; value=&quot;0&quot; /&amp;gt;&lt;br /&gt;		&amp;lt;/form&amp;gt;&lt;br /&gt;		&amp;lt;?php&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;After finishing off the table, we need to add a few hidden variables to the form to tie everything together. The 'option' variable identifies our component when the call to Joomla! is made so that we are properly routed. The 'task' variable is what our controller uses to determine which function to call. We set this as a blank at first; the toolbar buttons will be able to fill this in later. Finally, we set a 'boxchecked' variable so that the Javascript can keep track of how many checkboxes are ticked.&lt;/p&gt;
&lt;pre&gt;	}&lt;br /&gt;&lt;br /&gt;	function edit($option, &amp;amp;$row)&lt;br /&gt;	{&lt;br /&gt;		HTML_DailyMessage::setMessageToolbar($row-&amp;gt;id);&lt;br /&gt;&lt;br /&gt;		JHTML::_('behavior.calendar');&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The edit() function takes the name of the component as the first parameter and a reference to a database row object as the second. We call the setMessageToolbar() function, passing in the id of the row. This will allow the toolbar to make some slight adjustments depending on whether we are editing an existing record or creating a new one. As in the listMessages() function, we call the JHTML::_() function to pull in some common HTML. The 'behavior.calendar' element will put a &amp;lt;script&amp;gt; tag in the HTML header that will load the Javascript to power a popup calendar in the form.&lt;/p&gt;
&lt;pre&gt;		?&amp;gt;&lt;br /&gt;		&amp;lt;form action=&quot;index.php&quot; method=&quot;post&quot; name=&quot;adminForm&quot;&amp;gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Just like the list screen, we need to have our form pointing to index.php and named 'adminForm' for Javascript interaction.&lt;/p&gt;
&lt;pre&gt;			&amp;lt;div class=&quot;col100&quot;&amp;gt;&lt;br /&gt;			&amp;lt;fieldset class=&quot;adminform&quot;&amp;gt;&lt;br /&gt;			&amp;lt;table class=&quot;admintable&quot;&amp;gt;&lt;br /&gt;				&amp;lt;tbody&amp;gt;&lt;br /&gt;					&amp;lt;tr&amp;gt;&lt;br /&gt;						&amp;lt;td width=&quot;20%&quot; class=&quot;key&quot;&amp;gt;&lt;br /&gt;							&amp;lt;label for=&quot;message&quot;&amp;gt;Message&amp;lt;/label&amp;gt;&lt;br /&gt;						&amp;lt;/td&amp;gt;&lt;br /&gt;						&amp;lt;td&amp;gt;&lt;br /&gt;						&amp;lt;input class=&quot;inputbox&quot; type=&quot;text&quot; name=&quot;message&quot; id=&quot;message&quot; size=&quot;40&quot; value=&quot;&amp;lt;?php echo $row-&amp;gt;message; ?&amp;gt;&quot; /&amp;gt;&lt;br /&gt;						&amp;lt;/td&amp;gt;&lt;br /&gt;					&amp;lt;/tr&amp;gt;&lt;br /&gt;					&amp;lt;tr&amp;gt;&lt;br /&gt;						&amp;lt;td width=&quot;20%&quot; class=&quot;key&quot;&amp;gt;&lt;br /&gt;							&amp;lt;label for=&quot;date&quot;&amp;gt;Date&amp;lt;/label&amp;gt;&lt;br /&gt;						&amp;lt;/td&amp;gt;&lt;br /&gt;						&amp;lt;td&amp;gt;&lt;br /&gt;						&amp;lt;input class=&quot;inputbox&quot; type=&quot;text&quot; name=&quot;date&quot; id=&quot;date&quot; size=&quot;40&quot; value=&quot;&amp;lt;?php echo $row-&amp;gt;date; ?&amp;gt;&quot; /&amp;gt;&lt;br /&gt;						&amp;lt;input type=&quot;reset&quot; class=&quot;button&quot; value=&quot;...&quot; onclick=&quot;return showCalendar('date', 'y-mm-dd');&quot; /&amp;gt;&lt;br /&gt;						&amp;lt;/td&amp;gt;&lt;br /&gt;					&amp;lt;/tr&amp;gt;&lt;br /&gt;					&amp;lt;tr&amp;gt;&lt;br /&gt;						&amp;lt;td width=&quot;20%&quot; class=&quot;key&quot;&amp;gt;&lt;br /&gt;							&amp;lt;label for=&quot;published&quot;&amp;gt;Published&amp;lt;/label&amp;gt;&lt;br /&gt;						&amp;lt;/td&amp;gt;&lt;br /&gt;						&amp;lt;td&amp;gt;&lt;br /&gt;							&amp;lt;?php echo JHTML::_('select.booleanlist',  'published', '', $row-&amp;gt;published ); ?&amp;gt;&lt;br /&gt;						&amp;lt;/td&amp;gt;&lt;br /&gt;					&amp;lt;/tr&amp;gt;&lt;br /&gt;				&amp;lt;/tbody&amp;gt;&lt;br /&gt;			&amp;lt;/table&amp;gt;&lt;br /&gt;			&amp;lt;/fieldset&amp;gt;&lt;br /&gt;		&amp;lt;/div&amp;gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The edit form uses the 'col100', 'adminform', 'admintable', 'key', 'button', and 'inputbox' classes to format the output to look like other forms in the Joomla! admin interface. The 'message' and 'date' variables are directly populated with values from the $row object. Next to the date field, we build a form button and assign an onclick event to it that displays our popup calendar when clicked. Since we pass 'date' into this Javascript function, it will look for the input named 'date' and fill it in with is chosen from the popup. The 'published' field is represented as a radio button, which we generate using JTHML::_('select.booleanlist', ... ),&lt;/p&gt;
&lt;pre&gt;		&amp;lt;input type=&quot;hidden&quot; name=&quot;option&quot; value=&quot;&amp;lt;?php echo $option; ?&amp;gt;&quot; /&amp;gt;&lt;br /&gt;		&amp;lt;input type=&quot;hidden&quot; name=&quot;task&quot; value=&quot;&quot; /&amp;gt;&lt;br /&gt;		&amp;lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;&amp;lt;?php echo $row-&amp;gt;id ?&amp;gt;&quot; /&amp;gt;&lt;br /&gt;		&amp;lt;/form&amp;gt;&lt;br /&gt;		&amp;lt;?php&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;As with the message list, we need a few hidden variables to take care of a few things. We include the 'option' value and a blank 'task' variable as we did before. We also add an 'id' field which is set to the row id, if it exists. If no value is provided here or it does not exist, our code will assume that it is a new record and will add it to the database.&lt;/p&gt;
&lt;pre&gt;	}&lt;br /&gt;&lt;br /&gt;	function setMessageToolbar($id)&lt;br /&gt;	{&lt;br /&gt;		if ($id) {&lt;br /&gt;			$newEdit = 'Edit';&lt;br /&gt;		} else {&lt;br /&gt;			$newEdit = 'New';&lt;br /&gt;		}&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;We called setMessageToolbar() from our edit() function to configure the toolbar for our editing screen. It takes the row $id as the parameter. We use this to determine if we are adding or editing a message and set $newEdit accordingly.&lt;/p&gt;
&lt;pre&gt;		JToolBarHelper::title($newEdit . ' Message', 'generic.png');&lt;br /&gt;		JToolBarHelper::save();&lt;br /&gt;		JToolBarHelper::cancel();&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The JToolBarHelper member functions add toolbar buttons in the order you call them. The exception to this is the title() function which sets the screen title to the left of the toolbar. Using our $newEdit variable set above, we set this message, then pass in the name of the image we want to use as the icon for the title. After setting the title, we add the 'save' and 'cancel' buttons to the toolbar. When these are clicked, they will set the task variable in the form to 'save' and 'cancel' respectively.&lt;/p&gt;
&lt;pre&gt;	}&lt;br /&gt;&lt;br /&gt;	function setAllMessagesToolbar()&lt;br /&gt;	{&lt;br /&gt;		JToolBarHelper::title('Message Manager', 'generic.png');&lt;br /&gt;		JToolBarHelper::publishList();&lt;br /&gt;		JToolBarHelper::unpublishList();&lt;br /&gt;		JToolBarHelper::deleteList();&lt;br /&gt;		JToolBarHelper::editList();&lt;br /&gt;		JToolBarHelper::addNew();&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Like the toolbar for editing, we set the title first along with an icon. Then we proceed to add buttons for publishing, unpublishing, deleting, editing, and adding, which set task to 'publish', 'unpublish', 'remove', 'edit', and 'add' respectively. The functions names ending in 'List' also check to make sure that at least one of the checkboxes is ticked before submitting the form. Otherwise, a Javascript alert appears.&lt;/p&gt;
&lt;pre&gt;	}&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;tablesdailymessage&quot; class=&quot;dailymessage&quot;&gt;tables/dailymessage.php&lt;/h3&gt;
&lt;div class=&quot;source&quot;&gt;
&lt;pre&gt;&amp;lt;?php&lt;br /&gt;&lt;br /&gt;defined( '_JEXEC' ) or die( 'Restricted access' );&lt;br /&gt;&lt;br /&gt;class TableDailyMessage extends JTable&lt;br /&gt;{&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;We start by checking to make sure that we are inside of Joomla!, then declare the TableDailyMessage class as an extension of the JTable class.&lt;/p&gt;
&lt;pre&gt;	var $id = null;&lt;br /&gt;	var $message = null;&lt;br /&gt;	var $date = null;&lt;br /&gt;	var $published = null;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;These four variables match the four columns found in the #__dailymessage table in the database. We begin by setting them to null. This makes it easier for the class to generate SQL UPDATE commands: it can skip over any variable that is still set to null.&lt;/p&gt;
&lt;pre&gt;	function __construct(&amp;amp;$db)&lt;br /&gt;	{&lt;br /&gt;		parent::__construct( '#__dailymessage', 'id', $db );&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The only method we are defining for TableDailyMessage is __construct(). This is PHP 5's constructor which is emulated under PHP 4 (if you are still running that version). The current database object gets passed in by reference. Right away, we call JTable's original constructor and pass in the name of our table (with the #__ prefix shorthand), the name of the key column, and the database object. Since we have identified the 'id' column as the key, the object will know when to generate UPDATE rather than INSERT statements based on whether 'id' is set. It will also use this key when we call the load() or delete() functions.&lt;/p&gt;
&lt;pre&gt;		jimport('joomla.utilities.date');&lt;br /&gt;		$now = new JDate();&lt;br /&gt;		$this-&amp;gt;set( 'date', $now-&amp;gt;toMySQL() );&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;We also want to set the current date as the default value for 'date' in the event that none is specified. First, we call jimport() to pull in the date utilities, then create a date object and store it in $now. (This object defaults to the current date and time.) Then we call JTable's set() member function, passing in 'date' (the column we wish to set) and then the date we wish to set it to. The toMySQL() member function of the JDate class takes the date represented in the object and returns a MySQL-formatted copy.&lt;/p&gt;
&lt;pre&gt;	}&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;dailymessagexml&quot; class=&quot;dailymessage&quot;&gt;dailymessage.xml&lt;/h3&gt;
&lt;div class=&quot;source&quot;&gt;
&lt;pre&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&lt;br /&gt;&amp;lt;install type=&quot;component&quot; version=&quot;1.5.0&quot;&amp;gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;This XML file serves three purposes: identifying our component, guiding the component installation/removal, and providing the configuration parameters that are available when we create a menu link to the component. The first line of this file identifies it as an XML 1.0 document in UTF-8 format. We continue with an opening &amp;lt;install&amp;gt; tag that encloses the rest of the file. We identify the package type as a component and designate that it is intended for Joomla! 1.5.0.&lt;/p&gt;
&lt;pre&gt;	&amp;lt;name&amp;gt;Daily Message&amp;lt;/name&amp;gt;&lt;br /&gt;	&amp;lt;author&amp;gt;Joseph LeBlanc&amp;lt;/author&amp;gt;&lt;br /&gt;	&amp;lt;creationDate&amp;gt;August 2007&amp;lt;/creationDate&amp;gt;&lt;br /&gt;	&amp;lt;copyright&amp;gt;(C) 2004 - 2007 Joseph L. LeBlanc. All rights reserved.&amp;lt;/copyright&amp;gt;&lt;br /&gt;	&amp;lt;license&amp;gt;http://www.opensource.org/licenses/mit-license.php MIT&amp;lt;/license&amp;gt;&lt;br /&gt;	&amp;lt;authorEmail&amp;gt;contact@jlleblanc.com&amp;lt;/authorEmail&amp;gt;&lt;br /&gt;	&amp;lt;authorUrl&amp;gt;www.jlleblanc.com&amp;lt;/authorUrl&amp;gt;&lt;br /&gt;	&amp;lt;version&amp;gt;1.5.0&amp;lt;/version&amp;gt;&lt;br /&gt;	&amp;lt;description&amp;gt;Manages message for dates&amp;lt;/description&amp;gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The &amp;lt;name&amp;gt;, &amp;lt;author&amp;gt;, &amp;lt;creationDate&amp;gt;, &amp;lt;copyright&amp;gt;, &amp;lt;license&amp;gt;, &amp;lt;authorEmail&amp;gt;, &amp;lt;authorUrl&amp;gt;, &amp;lt;version&amp;gt;, and &amp;lt;description&amp;gt; elements are all used to identify the component within Joomla!. Although in this case the &amp;lt;version&amp;gt; element matches the version attribute on the &amp;lt;install&amp;gt; tag, this element is intended to identify the version of your component (rather than the target Joomla! version).&lt;/p&gt;
&lt;pre&gt;	&amp;lt;install&amp;gt;&lt;br /&gt;		&amp;lt;sql&amp;gt;&lt;br /&gt;			&amp;lt;file driver=&quot;mysql&quot; charset=&quot;utf8&quot;&amp;gt;install.mysql.sql&amp;lt;/file&amp;gt;&lt;br /&gt;		&amp;lt;/sql&amp;gt;&lt;br /&gt;	&amp;lt;/install&amp;gt;&lt;br /&gt;&lt;br /&gt;	&amp;lt;uninstall&amp;gt;&lt;br /&gt;		&amp;lt;sql&amp;gt;&lt;br /&gt;			&amp;lt;file driver=&quot;mysql&quot; charset=&quot;utf8&quot;&amp;gt;uninstall.mysql.sql&amp;lt;/file&amp;gt;&lt;br /&gt;		&amp;lt;/sql&amp;gt;&lt;br /&gt;	&amp;lt;/uninstall&amp;gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;These tags identify the SQL files to run when installing and uninstalling the component. Joomla! is designed to support multiple database types. If you want to support other databases in addition to MySQL, you will need to add separate SQL files to these sections.&lt;/p&gt;
&lt;pre&gt;	&amp;lt;files&amp;gt;&lt;br /&gt;		&amp;lt;filename&amp;gt;dailymessage.php&amp;lt;/filename&amp;gt;&lt;br /&gt;	&amp;lt;/files&amp;gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;This section identifies all of the files going into the frontend portion (/components/com_dailymessage) of the component. Daily Message has a very simple frontend, so only dailymessage.php is included.&lt;/p&gt;
&lt;pre&gt;	&amp;lt;params&amp;gt;&lt;br /&gt;		&amp;lt;param name=&quot;bold&quot; type=&quot;radio&quot; default=&quot;0&quot; label=&quot;Bold&quot; description=&quot;Display messages in bold&quot;&amp;gt;&lt;br /&gt;			&amp;lt;option value=&quot;0&quot;&amp;gt;No&amp;lt;/option&amp;gt;&lt;br /&gt;			&amp;lt;option value=&quot;1&quot;&amp;gt;Yes&amp;lt;/option&amp;gt;&lt;br /&gt;		&amp;lt;/param&amp;gt;&lt;br /&gt;		&amp;lt;param name=&quot;italic&quot; type=&quot;radio&quot; default=&quot;0&quot; label=&quot;Italic&quot; description=&quot;Display messages in italics&quot;&amp;gt;&lt;br /&gt;			&amp;lt;option value=&quot;0&quot;&amp;gt;No&amp;lt;/option&amp;gt;&lt;br /&gt;			&amp;lt;option value=&quot;1&quot;&amp;gt;Yes&amp;lt;/option&amp;gt;&lt;br /&gt;		&amp;lt;/param&amp;gt;&lt;br /&gt;		&amp;lt;param name=&quot;underline&quot; type=&quot;radio&quot; default=&quot;0&quot; label=&quot;Underline&quot; description=&quot;Display messages with an underline&quot;&amp;gt;&lt;br /&gt;			&amp;lt;option value=&quot;0&quot;&amp;gt;No&amp;lt;/option&amp;gt;&lt;br /&gt;			&amp;lt;option value=&quot;1&quot;&amp;gt;Yes&amp;lt;/option&amp;gt;&lt;br /&gt;		&amp;lt;/param&amp;gt;&lt;br /&gt;	&amp;lt;/params&amp;gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;When we create a frontend link to the Daily Message component, we want to do some quick configuration. These &amp;lt;param&amp;gt; tags allow us to provide several options. On the link editing screen, these tags will be read and HTML elements will automatically be generated based on them. When the administrator saves the link, the values chosen will be saved along with the menu item; there is no need to create another table or any other place to store this information.&lt;/p&gt;
&lt;pre&gt;	&amp;lt;administration&amp;gt;&lt;br /&gt;		&amp;lt;menu&amp;gt;Daily Message&amp;lt;/menu&amp;gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Some of the elements of our component are distinctly a part of the backend and should never reach the frontend. We put these within the &amp;lt;administration&amp;gt; tags. To begin, we add a &amp;lt;menu&amp;gt; tag defining the name of the item added to the Components menu. This will give administrators a link to the list screen in backend of the component.&lt;/p&gt;
&lt;pre&gt;		&amp;lt;files folder=&quot;admin&quot;&amp;gt;&lt;br /&gt;			&amp;lt;filename&amp;gt;install.mysql.sql&amp;lt;/filename&amp;gt;&lt;br /&gt;			&amp;lt;filename&amp;gt;uninstall.mysql.sql&amp;lt;/filename&amp;gt;&lt;br /&gt;			&amp;lt;filename&amp;gt;admin.dailymessage.php&amp;lt;/filename&amp;gt;&lt;br /&gt;			&amp;lt;filename&amp;gt;admin.dailymessage.html.php&amp;lt;/filename&amp;gt;&lt;br /&gt;			&amp;lt;filename&amp;gt;controller.php&amp;lt;/filename&amp;gt;&lt;br /&gt;			&amp;lt;filename&amp;gt;LICENSE&amp;lt;/filename&amp;gt;&lt;br /&gt;			&amp;lt;filename&amp;gt;tables/dailymessage.php&amp;lt;/filename&amp;gt;&lt;br /&gt;		&amp;lt;/files&amp;gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The &amp;lt;files&amp;gt; tag encloses a list of files to be copied to /administrator/components/com_dailymessage. Within our .zip file, there is a folder named 'admin' where all of these files are kept. Notice that we are again listing install.mysql.sql and uninstall.mysql.sql: if we do not do this, these files will not be copied and will not get executed. Also, when we list files under subdirectores (like tables/dailymessage.php), these subdirectories will automatically be created under /administrator/components/com_dailymessage.&lt;/p&gt;
&lt;pre&gt;	&amp;lt;/administration&amp;gt;&lt;br /&gt;&lt;br /&gt;&amp;lt;/install&amp;gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;These two closing tags finish off the file.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a class=&quot;online&quot; href=&quot;http://jlleblanc.com/com_dailymessage15.zip&quot;&gt;Download a copy of the component here.&lt;/a&gt;&lt;/p&gt;</summary>
		<content type="html">&lt;p class=&quot;online&quot;&gt;This tutorial is designed to help you build a complete component with a backend and frontend. After reading the tutorial, you should understand how some of the core classes and functions work so that you can use them in your own components. A full, ready to install copy of the component can be &lt;a href=&quot;http://jlleblanc.com/com_dailymessage15.zip&quot;&gt;downloaded here&lt;/a&gt;. This tutorial is designed for Joomla 1.5; &lt;a href=&quot;http://jlleblanc.com/index.php?option=com_content&amp;amp;task=view&amp;amp;id=9&quot;&gt;a version for 1.0 can be found here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Different people will understand the functionality of Joomla components in different ways. Developers with significant previous PHP experience may wish to start with dailymessage.php (the file generating the frontend display) and admin.dailymessage.php (generates the backend display). Others will want to start with the XML document which maps out every code source, image, and SQL query.&lt;/p&gt;
&lt;h3 id=&quot;dailymessage&quot; class=&quot;dailymessage&quot;&gt;dailymessage.php&lt;/h3&gt;
&lt;div class=&quot;source&quot;&gt;
&lt;p&gt;When you click on a link to the Daily Message component from the frontend, the file dailymessage.php in the /components/com_dailymessage folder is executed. You can add any valid PHP code you wish from here, but there are some security measures you should take even if you are not going to be using Joomla!'s libraries.&lt;/p&gt;
&lt;pre&gt;&amp;lt;?php&lt;br /&gt;&lt;br /&gt;defined('_JEXEC') or die();&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;As with every file of source code in Joomla!, we start with an opening PHP tag. We also use the defined() call to check to make sure that Joomla! is requesting dailymessage.php and that it is not being requested directly. If it is being requested directly, we quit right away.&lt;/p&gt;
&lt;pre&gt;$db =&amp;amp; JFactory::getDBO();&lt;br /&gt;&lt;br /&gt;$db-&amp;gt;setQuery(&quot;SELECT * FROM #__dailymessage WHERE published = 1 ORDER BY date&quot;);&lt;br /&gt;$rows = $db-&amp;gt;loadObjectList();&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The first thing we want to do is to grab all of the published messages from the database so that we can prepare them for display. To do this, we first get a reference to the database Joomla! is currently connected to. Next, we pass our query into the setQuery() member function. The prefix #__ will be converted to jos_ (or whatever database prefix you chose for your installation) when the query is actually run. To get the rows out, we call the loadObjectList() function which returns an array of row objects. This array gets stored in $rows.&lt;/p&gt;
&lt;pre&gt;list($begin, $end) = getMessageFormat();&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Our component has some configuration that allows the administrator to add bold, underline, and italicize tags around each message. The getMessageFormat() function (defined in this file below) returns an array with the opening and closing tags. We use PHP's list() language construct to extract the two array elements into $begin and $end.&lt;/p&gt;
&lt;pre&gt;echo '&amp;lt;ul&amp;gt;';&lt;br /&gt;&lt;br /&gt;foreach ($rows as $row) {&lt;br /&gt;	echo '&amp;lt;li&amp;gt;' . JHTML::date($row-&amp;gt;date) . ' ' . $begin . $row-&amp;gt;message . $end . '&amp;lt;/li&amp;gt;';&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;echo '&amp;lt;/ul&amp;gt;';&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;To list the daily messages, we start by outputting an opening unordered list tag. Then we cycle over each record in the $rows array and output a list item for each. The JHTML::date() function formats the value of $row-&amp;gt;date according to the preferences set in Joomla!. The beginning formatting tags are output, followed by the message in $row-&amp;gt;message, followed by the ending formatting tags.&lt;/p&gt;
&lt;pre&gt;function getMessageFormat()&lt;br /&gt;{&lt;br /&gt;	$params =&amp;amp; JComponentHelper::getParams('com_dailymessage');&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;In Joomla!, menu items control the appearance and behavior of a page, as well as the configuration for a component. This function is designed to get the configuration for the current menu item and return an appropriate set of formatting tags. The getParams() member function of JComponentHelper returns a parameters object when we pass in the name of a component (in this case, com_dailymessage). Since we are loading com_dailymessage, we get the parameters set for the current menu item and store them in $params.&lt;/p&gt;
&lt;pre&gt;	$italic = $params-&amp;gt;get('italic', false);&lt;br /&gt;	$bold = $params-&amp;gt;get('bold', false);&lt;br /&gt;	$underline = $params-&amp;gt;get('underline', false);&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The get() member function of the $params object returns the values for parameter names you pass in. In addition to the names, you can specify a default value for your parameters (in our case, false).&lt;/p&gt;
&lt;pre&gt;	$begin = '';&lt;br /&gt;	$end = '';&lt;br /&gt;&lt;br /&gt;	if ($italic) {&lt;br /&gt;		$begin .= '&amp;lt;i&amp;gt;';&lt;br /&gt;		$end = '&amp;lt;/i&amp;gt;' . $end;&lt;br /&gt;	}&lt;br /&gt;&lt;br /&gt;	if ($bold) {&lt;br /&gt;		$begin .= '&amp;lt;b&amp;gt;';&lt;br /&gt;		$end = '&amp;lt;/b&amp;gt;' . $end;&lt;br /&gt;	}&lt;br /&gt;&lt;br /&gt;	if ($underline) {&lt;br /&gt;		$begin .= '&amp;lt;u&amp;gt;';&lt;br /&gt;		$end = '&amp;lt;/u&amp;gt;' . $end;&lt;br /&gt;	}&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Before building our formatting tags, we set $begin and $end as blank strings. We then test each of the variables we just set using $params-&amp;gt;get(). If they are set to something other than false or 0, we add the appropriate tags to the $begin and $end strings; the $begin tags are appended, while the $end tags are prepended.&lt;/p&gt;
&lt;pre&gt;	$format = array($begin, $end);&lt;br /&gt;&lt;br /&gt;	return $format;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we set $format to the contents of $begin and $end with a space between, then return $format.&lt;/p&gt;
&lt;pre&gt;}&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;admindailymessage&quot; class=&quot;dailymessage&quot;&gt;admin.dailymessage.php&lt;/h3&gt;
&lt;div class=&quot;source&quot;&gt;
&lt;p&gt;When you go to the backend and choose Daily Message from the Components menu, the file admin.dailymessage.php in the /administrator/components/com_dailymessage folder is executed. This file can contain any PHP code you desire, but you are probably more interested in generating screens that look like the ones in other components.&lt;/p&gt;
&lt;pre&gt;&amp;lt;?php&lt;br /&gt;&lt;br /&gt;defined('_JEXEC') or die();&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;We begin with an opening &amp;lt;?php tag and a call to defined(). This particular call makes sure that the code is being executed from within Joomla!. If not, PHP will stop right away. This is to prevent people from running your code outside of Joomla!. Without this line, someone would be able to pull up http://www.yoursite.com/administrator/components/com_dailymessage/admin.dailymessage.php without having to first log into the backend, leaving them free to use the functions you intended only for admins. For this reason, place this line at the top of each one of your files of code.&lt;/p&gt;
&lt;pre&gt;JTable::addIncludePath(JPATH_COMPONENT.DS.'tables');&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;This call to the addIncludePath() member function of JTable pulls in all of the files in our directory of database table classes. Any classes contained in these files will be available through JTable. The JPATH_COMPONENT constant is automatically defined by Joomla! to point to the current directory where our component script is running. A directory separator appropriate to the host operating system is defined in DS. Therefore, if our installation of Joomla! was hosted at /var/www on our host, the resulting string in the call to addIncludePath() would be /var/www/administrator/components/com_dailymessage/tables.&lt;/p&gt;
&lt;pre&gt;require_once(JPATH_COMPONENT.DS.'controller.php');&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The logic flow through our backend component will be handled through a controller. Our controller makes it simple to add new functions to the component in an organized, predictable way.&lt;/p&gt;
&lt;pre&gt;$controller = new DailyMessageController();&lt;br /&gt;$controller-&amp;gt;registerDefaultTask('listMessages');&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;To get the controller started, we assign a new instance of DailyMessageController to $controller. Next, we use the registerDefaultTask() member function to specify which function should be executed when the user either does not choose one or tries to use one that does not exist.&lt;/p&gt;
&lt;pre&gt;$task = JRequest::getCmd('task');&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;When we pass in 'task', the getCmd() member function of JRequest will return the name of the function the user is trying to run. This can appear in the URL (http://www.yoursite.com/administrator/index.php?option=com_dailymessage&amp;amp;task=iwanttorunthistask), be included in the HTTP POST variables, or be otherwise generated by the Joomla! framework.&lt;/p&gt;
&lt;pre&gt;$controller-&amp;gt;execute($task);&lt;br /&gt;$controller-&amp;gt;redirect();&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;With the correct $task in hand, we pass it off to execute() where it is matched up to the name of a function. Finally, we call redirect(). If we executed a $task that did not result in a screen, we need to redirect the browser to another task that does.&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id=&quot;controller&quot; class=&quot;dailymessage&quot;&gt;controller.php&lt;/h3&gt;
&lt;div class=&quot;source&quot;&gt;
&lt;p&gt;This file includes a controller based on the JController base class included with Joomla!. It automates the logical flow of our component so we can concentrate on adding new functions as we need them without disturbing older ones. We pass in the task we want to run into execute() and the controller handles the rest.&lt;/p&gt;
&lt;pre&gt;&amp;lt;?php&lt;br /&gt;&lt;br /&gt;defined('_JEXEC') or die();&lt;br /&gt;&lt;br /&gt;jimport('joomla.application.component.controller');&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Once again, we begin with an opening &amp;lt;?php tag and a check to make sure that _JEXEC has been set. We also use the jimport() function to pull in the code for the JController base class. Joomla! is in the habit of keeping the code in memory to a minimum (to keep performance fast), while providing a large library of functions and classes for you to use where desired.&lt;/p&gt;
&lt;pre&gt;class DailyMessageController extends JController&lt;br /&gt;{&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;We declare our DailyMessageController class as an extension of JController. Extending this class provides ours with the registerDefaultTask(), execute(), and redirect() member functions we used in admin.dailymessage.php along with several others. All extensions of JController typically follow the convention of having a name ending in 'Controller', as ours does.&lt;/p&gt;
&lt;pre&gt;	function __construct()&lt;br /&gt;	{&lt;br /&gt;		parent::__construct();&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The __contstruct() function is called when a new DailyMessageController() is created. (The default behavior of PHP 5 does this by default where PHP 4 does not. Joomla!'s JObject base class adds this behavior to PHP 4). We call the JController constructor so that it can build an inventory of all of the tasks available.&lt;/p&gt;
&lt;pre&gt;		$this-&amp;gt;registerTask('add', 'edit');&lt;br /&gt;		$this-&amp;gt;registerTask('unpublish', 'publish');&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;There are two tasks, add and unpublish, that are almost identical in nature to other tasks present in the controller. Instead of writing entirely different functions for these with only minor changes, we use the registerTask() JController member function to tell the controller to call the edit function when we choose 'add' and the publish function when we select 'unpublish'. (While it might seem that unpublishing is the complete opposite of publishing, all we are really doing is changing a number in the database.)&lt;/p&gt;
&lt;pre&gt;	}&lt;br /&gt;&lt;br /&gt;	function save()&lt;br /&gt;	{&lt;br /&gt;		$option = JRequest::getCmd('option');&lt;br /&gt;		$this-&amp;gt;setRedirect('index.php?option=' . $option);&lt;br /&gt;	&lt;/pre&gt;
&lt;p&gt;The save() task will be adding and updating the data for our daily messages in the database. Since it will not normally generate output, we will want to redirect the user back to the main admin screen for our component when we are done saving. As we did with $task, passing 'option' into JRequest::getCmd() will return 'com_dailymessage'. (If we were to later change the name of our component to something else, say com_weeklymessage, this piece of code would return the new name instead.) The setRedirect() member function of JController specifies the URL we want to send the user to after the task is complete.&lt;/p&gt;
&lt;pre&gt;		$post = JRequest::get('post');&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The when we pass 'post' into the get() member function of JRequest, it processes and returns a cleaned copy of the variables in the $_POST array. Using get('post') instead of accessing $_POST provides us with a level of protection against malicious data.&lt;/p&gt;
&lt;pre&gt;		$row =&amp;amp; JTable::getInstance('DailyMessage', 'Table');&lt;/pre&gt;
&lt;p&gt;The getInstance() member function of JTable returns a database table object for the table where will will store our data. The name &quot;TableDailyMessage&quot; is assembled by getInstance() as the second parameter is the class name prefix and the first is the suffix.&lt;/p&gt;
&lt;pre&gt;		if (!$row-&amp;gt;bind($post)) {&lt;br /&gt;			return JError::raiseWarning(500, $row-&amp;gt;getError());&lt;br /&gt;		}&lt;br /&gt;&lt;br /&gt;		if (!$row-&amp;gt;store()) {&lt;br /&gt;			return JError::raiseWarning(500, $row-&amp;gt;getError());&lt;br /&gt;		}&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;We call two member functions of the database table object. Passing an array into bind() matches the keys and values of that array to the member variables of the database table class. Calling store() takes the member variables and executes an SQL statement for either an INSERT or UPDATE statement. If a value is provided for the table key, an UPDATE statement is used; otherwise an INSERT is generated. If either bind() or store() fails, we call the raiseWarning() member function of JError to stop the component and to dump the error to the screen so we can figure out how to fix it.&lt;/p&gt;
&lt;pre&gt;		$this-&amp;gt;setMessage('Message Saved');&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Finally, once the data has successfully made it into the database, we use JController's setMessage() member function to store a message to be displayed in the browser after the task is complete. Since the save() task does not produce any output, this message is added as a variable in the URL the browser is redirected to when the $controller-&amp;gt;redirect() function is called in controller.php.&lt;/p&gt;
&lt;pre&gt;	}&lt;br /&gt;&lt;br /&gt;	function edit()&lt;br /&gt;	{&lt;br /&gt;		$cid = JRequest::getVar('cid', array(), 'request', 'array');&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Similar to the $post variable in the save() task, we want to get an array from the HTTP request and we want Joomla! to make sure the contents are safe. The getVar() member function of JRequest works similar to get(), except that it only retrieves an element from one of the superglobal arrays ($_GET, $_POST, $_REQUEST, etc...). In this instance, we are getting the 'cid' variable. If this does not exist, we want to default to a blank array. We want Joomla! to pull this out of the $_REQUEST superglobal and want to ensure that the data is in fact an array.&lt;/p&gt;
&lt;pre&gt;		$row =&amp;amp; JTable::getInstance('DailyMessage', 'Table');&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;As in the save() task, we pull in a database table object for the table where the daily messages are stored.&lt;/p&gt;
&lt;pre&gt;		if (isset($cid[0])) {&lt;br /&gt;			$row-&amp;gt;load($cid[0]);&lt;br /&gt;		}&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Unlike the save() task, we first test to see if one of the records has been chosen by the user. The 'cid' form variable represents the checkboxes you see alongside a listing of records. If the user has checked at least one box, the ID of the first one checked will be present in $cid[0]. We then call the load() member function to get the corresponding record from the database. If no boxes have been checked, we will just have a 'blank' database table object.&lt;/p&gt;
&lt;pre&gt;		require_once(JPATH_COMPONENT.DS.'admin.dailymessage.html.php');&lt;br /&gt;		$option = JRequest::getCmd('option');&lt;br /&gt;		HTML_DailyMessage::edit($option, $row);&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Since the edit() task will be generating HTML output, we need to pull in the file with the functions that generate it: admin.dailymessage.html.php. Using JPATH_COMPONENT and DS allow us to get a path to our current directory and we just add the filename to the end. The function generating the edit form needs to know which component to point to, so we use JRequest::getCmd() to get the value of 'option'. Finally, we call HTML_DailyMessage::edit(), passing in the name of the component with the row of data (or the blank if one was not loaded) so that the form can be displayed.&lt;/p&gt;
&lt;pre&gt;	}&lt;br /&gt;&lt;br /&gt;	function remove()&lt;br /&gt;	{&lt;br /&gt;		$option = JRequest::getCmd('option');&lt;br /&gt;&lt;br /&gt;		$this-&amp;gt;setRedirect('index.php?option=' . $option);&lt;br /&gt;&lt;br /&gt;		$db	=&amp;amp; JFactory::getDBO();&lt;br /&gt;		$cid = JRequest::getVar('cid', array(), 'request', 'array');&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The remove() task looks for any IDs found in the 'cid' array and removes the corresponding daily messages from the database. Like the save() task, this task does not produce any direct output, so we capture the component name in $option and set our redirect to go back to the main component screen when the deleting is complete. We get a reference to the live database object as well as a copy of the 'cid' array from the request.&lt;/p&gt;
&lt;pre&gt;		$count = count($cid);&lt;br /&gt;&lt;br /&gt;		if ($count)&lt;br /&gt;		{&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Before attempting to remove records from the database, we first get a count of the number of IDs. If there are none, this entire block is skipped and the browser just redirects back to the main component screen (although the Javascript in the toolbar usually prevents this from happening in the first place).&lt;/p&gt;
&lt;pre&gt;			$db-&amp;gt;setQuery('DELETE FROM #__dailymessage WHERE id IN (' . implode( ',', $cid ) . ')' );&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;If the IDs are present, we create a query to delete them and pass it into the setQuery() member function of the database object. The constant #__ is automatically turned into your installation's database prefix (usually jos_) when it is run. PHP's implode() function takes our array of IDs and turns it into a comma separated string the database can understand.&lt;/p&gt;
&lt;pre&gt;			if (!$db-&amp;gt;query()) {&lt;br /&gt;				JError::raiseWarning( 500, $db-&amp;gt;getError() );&lt;br /&gt;			}&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;After the query is set, we call the database object's query() member function which executes that query. If a problem occurs, we stop processing, raise a warning, and display the error from the database for debugging.&lt;/p&gt;
&lt;pre&gt;			if ($count &amp;gt; 1) {&lt;br /&gt;				$s = 's';&lt;br /&gt;			} else {&lt;br /&gt;				$s = '';&lt;br /&gt;			}&lt;br /&gt;&lt;br /&gt;			$this-&amp;gt;setMessage('Message' . $s . ' removed');&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;If the deletion goes through with no problems, we add a message to be displayed on the main screen stating they were removed. First, we determine whether one or several records were removed and use this to properly pluralize the message. Then we call setMessage() so that the controller can add it to the redirection URL for display.&lt;/p&gt;
&lt;pre&gt;		}&lt;br /&gt;	}&lt;br /&gt;&lt;br /&gt;	function publish()&lt;br /&gt;	{&lt;br /&gt;		$option = JRequest::getCmd('option');&lt;br /&gt;&lt;br /&gt;		$this-&amp;gt;setRedirect('index.php?option=' . $option);&lt;br /&gt;&lt;br /&gt;		$cid = JRequest::getVar('cid', array(), 'request', 'array');&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The publish() task gets IDs from the 'cid' array and sets the publishing for these records. This is yet another task that does not produce any direct output, so we set our redirect to go back to the main list screen after we are done. The $cid variable gets set to the 'cid' array from the request.&lt;/p&gt;
&lt;pre&gt;		if ($this-&amp;gt;getTask() == 'publish') {&lt;br /&gt;			$publish = 1;&lt;br /&gt;		} else {&lt;br /&gt;			$publish = 0;&lt;br /&gt;		}&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The publish() task is set to handle both the 'publish' and 'unpublish' tasks. Because of this, we need to determine which task we are handling and act accordingly. The controller's getTask() member function returns this back to us value back to us. If it is equal to 'publish', we set $publish to 1, otherwise (when it is set to 'unpublish') we set $publish to 0.&lt;/p&gt;
&lt;pre&gt;		$table =&amp;amp; JTable::getInstance('DailyMessage', 'Table');&lt;br /&gt;&lt;br /&gt;		$table-&amp;gt;publish($cid, $publish);&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;After getting a database table object for the daily message table, we call JTable's publish() member function. This function takes an array of table key IDs and sets the 'publish' column of the rows with those IDs to the value of the second parameter.&lt;/p&gt;
&lt;pre&gt;		if (count($cid) &amp;gt; 1) {&lt;br /&gt;			$s = 's';&lt;br /&gt;		} else {&lt;br /&gt;			$s = '';&lt;br /&gt;		}&lt;br /&gt;&lt;br /&gt;		$action = ucfirst($this-&amp;gt;getTask()) . 'ed';&lt;br /&gt;&lt;br /&gt;		$this-&amp;gt;setMessage('Message' . $s . ' ' . $action);&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Once the publishing or unpublishing is complete, we are ready to redirect the user back to the list of messages. Before doing this, we need to assemble an appropriate message to display at the top of the screen when they land there. First, we count the number of records processed and set $s accordingly for pluralizing the word. Next, we again use the getTask() member function of the controller to get the name of the task we just published, capitalize the first letter, add 'ed' to the end, and store the result in $action. This way, $action will either say 'Published' or 'Unpublished'. Finally, we call the controller's setMessage() function to make it available on redirection.&lt;/p&gt;
&lt;pre&gt;	}&lt;br /&gt;&lt;br /&gt;	function listMessages()&lt;br /&gt;	{&lt;br /&gt;		$option = JRequest::getCmd('option');&lt;br /&gt;&lt;br /&gt;		$db	=&amp;amp; JFactory::getDBO();&lt;br /&gt;		$db-&amp;gt;setQuery(&quot;SELECT * FROM #__dailymessage&quot;);&lt;br /&gt;		$rows = $db-&amp;gt;loadObjectList();&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The listMessages() task gets all of the messages from the database, then passes these along to be turned into an admin screen where the messages are listed. First, we get the component name using JRequest::getCmd('option'), because it will be needed to build the form controlling the message list. Next, we get a reference to the current database object and use setQuery() to pass in our SELECT statement. Finally, we use the loadObjectList() member function, which returns all of the records in the database as an array of objects. Each of the objects in the $rows array represent a single row in the database table, with the column values available as public variables.&lt;/p&gt;
&lt;pre&gt;		require_once(JPATH_COMPONENT.DS.'admin.dailymessage.html.php');&lt;br /&gt;		HTML_DailyMessage::listMessages($option, $rows);&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Like the edit() task, we include admin.dailymessage.html.php so that we can call up the function for HTML output. Then we pass the current component name and the array of row objects into HTML_DailyMessage::listMessages() for display.&lt;/p&gt;
&lt;pre&gt;	}&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;admindailymessagehtml&quot; class=&quot;dailymessage&quot;&gt;admin.dailymessage.html.php&lt;/h3&gt;
&lt;div class=&quot;source&quot;&gt;
&lt;pre&gt;&amp;lt;?php&lt;br /&gt;&lt;br /&gt;defined('_JEXEC') or die();&lt;br /&gt;&lt;br /&gt;class HTML_DailyMessage&lt;br /&gt;{&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;As with the other files, we begin with our opening PHP tag, the check to make sure we are in Joomla!, and declare the HTML_DailyMessage class.&lt;/p&gt;
&lt;pre&gt;	function listMessages($option, &amp;amp;$rows)&lt;br /&gt;	{&lt;br /&gt;		HTML_DailyMessage::setAllMessagesToolbar();&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The listMessages() function takes the current component name as the first parameter, and an array of row objects as the second (using &amp;amp; to pass this array by reference to save memory). We then call the setAllMessagesToolbar() function in this same class to set up our toolbar buttons. Notice that we are not calling $this-&amp;gt;setAllMessagesToolbar(), since we are using HTML_DailyMessage statically.&lt;/p&gt;
&lt;pre&gt;		?&amp;gt;&lt;br /&gt;		&amp;lt;form action=&quot;index.php&quot; method=&quot;post&quot; name=&quot;adminForm&quot;&amp;gt;&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The form wrapping around all message record listings points to index.php (as all requests through Joomla! do) and is named 'adminForm'. Naming the form as such is very important so that the Javascript in Joomla!'s backend can interact with it.&lt;/p&gt;
&lt;pre&gt;			&amp;lt;table class=&quot;adminlist&quot;&amp;gt;&lt;br /&gt;				&amp;lt;thead&amp;gt;&lt;br /&gt;					&amp;lt;tr&amp;gt;&lt;br /&gt;					&amp;lt;th width=&quot;20&quot;&amp;gt;&lt;br /&gt;					&amp;lt;input type=&quot;checkbox&quot; name=&quot;toggle&quot; value=&quot;&quot;  onclick=&quot;checkAll(&amp;lt;?php echo count( $rows ); ?&amp;gt;);&quot; /&amp;gt;&lt;br /&gt;					&amp;lt;/th&amp;gt;&lt;br /&gt;					&amp;lt;th nowrap=&quot;nowrap&quot; class=&quot;title&quot;&amp;gt;Message&amp;lt;/th&amp;gt;&lt;br /&gt;					&amp;lt;th nowrap=&quot;nowrap&quot;&amp;gt;Date&amp;lt;/th&amp;gt;&lt;br /&gt;					&amp;lt;th nowrap=&quot;nowrap&quot;&amp;gt;Published&amp;lt;/th&amp;gt;&lt;br /&gt;					&amp;lt;/tr&amp;gt;&lt;br /&gt;				&amp;lt;/thead&amp;gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Our records are presented in a table, which is assigned the 'adminList' class. This makes the table appear with the same style as other components in the Joomla! backend. Next, we create the header row. The first header column is a checkbox that will allow the user to toggle on or off all of the records on screen at once. We give it the name 'toggle' and assign an onclick event, passing in the total number of rows being displayed on the screen.&lt;/p&gt;
&lt;pre&gt;				&amp;lt;tbody&amp;gt;&lt;br /&gt;&lt;br /&gt;					&amp;lt;?php&lt;br /&gt;&lt;br /&gt;					$k = 0;&lt;br /&gt;					for ($i=0, $n=count( $rows ); $i &amp;lt; $n; $i++) {&lt;br /&gt;						$row = &amp;amp;$rows[$i];&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;We begin our loop through the records by first setting $k to 0, which we will use to help us alternate the row styles. Next, we set our for() loop with $i starting at 0 and $n equaling the total number of rows to be displayed. Inside the loop, we set $row to a reference of the object in the array at position $i.&lt;/p&gt;
&lt;pre&gt;						$published = JHTML::_('grid.published', $row, $i );&lt;br /&gt; 						$checked = JHTML::_('grid.id', $i, $row-&amp;gt;id );&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Before outputting the row, we want to build a couple of elements so that we can essentially echo out the rest. The JHTML::_() function allows us to get commonly used HTML from the Joomla! library. To reduce the amount of code in memory, Joomla! only loads the functions for the particular HTML elements we want when we want them. To do this, we pass in the name of the element desired as the first parameter, then all of the other parameters for that element afterwards. The JHTML class does the rest, without the need to call jimport() to pull in the necessary files. For the publishing button, we pass in our $row and the current record number in $i. For the checkbox, we pass in the record number first, then the $row.&lt;/p&gt;
&lt;pre&gt;						$link = 'index.php?option=' . $option . '&amp;amp;task=edit&amp;amp;cid[]='. $row-&amp;gt;id;&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;We also build the URL for the links to messages using the component name and the id of the $row. The cid[] variable in the URL will match the form variable for the checkbox, it will all look the same to our controller.&lt;/p&gt;
&lt;pre&gt;						?&amp;gt;&lt;br /&gt;						&amp;lt;tr class=&quot;&amp;lt;?php echo &quot;row$k&quot;; ?&amp;gt;&quot;&amp;gt;&lt;br /&gt;							&amp;lt;td align=&quot;center&quot;&amp;gt;&lt;br /&gt;								&amp;lt;?php echo $checked; ?&amp;gt;&lt;br /&gt;							&amp;lt;/td&amp;gt;&lt;br /&gt;							&amp;lt;td&amp;gt;&lt;br /&gt;								&amp;lt;a href=&quot;http://jlleblanc.com/&amp;lt;?php echo $link; ?&amp;gt;&quot; title=&quot;Edit Message&quot;&amp;gt;&lt;br /&gt;									&amp;lt;?php echo $row-&amp;gt;message; ?&amp;gt;&lt;br /&gt;								&amp;lt;/a&amp;gt;&lt;br /&gt;							&amp;lt;/td&amp;gt;&lt;br /&gt;							&amp;lt;td&amp;gt;&lt;br /&gt;								&amp;lt;?php echo JHTML::date($row-&amp;gt;date); ?&amp;gt;&lt;br /&gt;							&amp;lt;/td&amp;gt;&lt;br /&gt;							&amp;lt;td align=&quot;center&quot;&amp;gt;&lt;br /&gt;								&amp;lt;?php echo $published; ?&amp;gt;&lt;br /&gt;							&amp;lt;/td&amp;gt;&lt;br /&gt;						&amp;lt;?php&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Outputting the row is straightforward. First, we start the row and assign the &amp;lt;tr&amp;gt; element with the class 'row$k', where $k is either a 1 or 0. The background of class 'row1' is slightly darker than 'row0', which creates an alternating visual effect. The checkbox and link URL are simply echoed out, as well as the publishing button. The text for the editing URL is the daily message itself, which is found in the $row object's 'message' member variable (just like the 'message' column in the database). The 'date' column in the database is in MySQL date format, which is usually not what we want to display. Passing this through JHTML::date() formats it according to the display preferences of the user.&lt;/p&gt;
&lt;pre&gt;						$k = 1 - $k;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;This line may appear a little odd, but it helps to create the alternating bar visual effect on the table. If $k is set to 0, we subtract it from 1 and end up with 1 for the next cycle through the loop. When $k is already set to 1, we subtract 1 and get back to 0. This way, the rows alternate evenly between row0 and row1.&lt;/p&gt;
&lt;pre&gt;					}&lt;br /&gt;&lt;br /&gt;					?&amp;gt;&lt;br /&gt;				&amp;lt;/tbody&amp;gt;&lt;br /&gt;			&amp;lt;/table&amp;gt;&lt;br /&gt;&lt;br /&gt;			&amp;lt;input type=&quot;hidden&quot; name=&quot;option&quot; value=&quot;&amp;lt;?php echo $option; ?&amp;gt;&quot; /&amp;gt;&lt;br /&gt;			&amp;lt;input type=&quot;hidden&quot; name=&quot;task&quot; value=&quot;&quot; /&amp;gt;&lt;br /&gt;			&amp;lt;input type=&quot;hidden&quot; name=&quot;boxchecked&quot; value=&quot;0&quot; /&amp;gt;&lt;br /&gt;		&amp;lt;/form&amp;gt;&lt;br /&gt;		&amp;lt;?php&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;After finishing off the table, we need to add a few hidden variables to the form to tie everything together. The 'option' variable identifies our component when the call to Joomla! is made so that we are properly routed. The 'task' variable is what our controller uses to determine which function to call. We set this as a blank at first; the toolbar buttons will be able to fill this in later. Finally, we set a 'boxchecked' variable so that the Javascript can keep track of how many checkboxes are ticked.&lt;/p&gt;
&lt;pre&gt;	}&lt;br /&gt;&lt;br /&gt;	function edit($option, &amp;amp;$row)&lt;br /&gt;	{&lt;br /&gt;		HTML_DailyMessage::setMessageToolbar($row-&amp;gt;id);&lt;br /&gt;&lt;br /&gt;		JHTML::_('behavior.calendar');&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The edit() function takes the name of the component as the first parameter and a reference to a database row object as the second. We call the setMessageToolbar() function, passing in the id of the row. This will allow the toolbar to make some slight adjustments depending on whether we are editing an existing record or creating a new one. As in the listMessages() function, we call the JHTML::_() function to pull in some common HTML. The 'behavior.calendar' element will put a &amp;lt;script&amp;gt; tag in the HTML header that will load the Javascript to power a popup calendar in the form.&lt;/p&gt;
&lt;pre&gt;		?&amp;gt;&lt;br /&gt;		&amp;lt;form action=&quot;index.php&quot; method=&quot;post&quot; name=&quot;adminForm&quot;&amp;gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Just like the list screen, we need to have our form pointing to index.php and named 'adminForm' for Javascript interaction.&lt;/p&gt;
&lt;pre&gt;			&amp;lt;div class=&quot;col100&quot;&amp;gt;&lt;br /&gt;			&amp;lt;fieldset class=&quot;adminform&quot;&amp;gt;&lt;br /&gt;			&amp;lt;table class=&quot;admintable&quot;&amp;gt;&lt;br /&gt;				&amp;lt;tbody&amp;gt;&lt;br /&gt;					&amp;lt;tr&amp;gt;&lt;br /&gt;						&amp;lt;td width=&quot;20%&quot; class=&quot;key&quot;&amp;gt;&lt;br /&gt;							&amp;lt;label for=&quot;message&quot;&amp;gt;Message&amp;lt;/label&amp;gt;&lt;br /&gt;						&amp;lt;/td&amp;gt;&lt;br /&gt;						&amp;lt;td&amp;gt;&lt;br /&gt;						&amp;lt;input class=&quot;inputbox&quot; type=&quot;text&quot; name=&quot;message&quot; id=&quot;message&quot; size=&quot;40&quot; value=&quot;&amp;lt;?php echo $row-&amp;gt;message; ?&amp;gt;&quot; /&amp;gt;&lt;br /&gt;						&amp;lt;/td&amp;gt;&lt;br /&gt;					&amp;lt;/tr&amp;gt;&lt;br /&gt;					&amp;lt;tr&amp;gt;&lt;br /&gt;						&amp;lt;td width=&quot;20%&quot; class=&quot;key&quot;&amp;gt;&lt;br /&gt;							&amp;lt;label for=&quot;date&quot;&amp;gt;Date&amp;lt;/label&amp;gt;&lt;br /&gt;						&amp;lt;/td&amp;gt;&lt;br /&gt;						&amp;lt;td&amp;gt;&lt;br /&gt;						&amp;lt;input class=&quot;inputbox&quot; type=&quot;text&quot; name=&quot;date&quot; id=&quot;date&quot; size=&quot;40&quot; value=&quot;&amp;lt;?php echo $row-&amp;gt;date; ?&amp;gt;&quot; /&amp;gt;&lt;br /&gt;						&amp;lt;input type=&quot;reset&quot; class=&quot;button&quot; value=&quot;...&quot; onclick=&quot;return showCalendar('date', 'y-mm-dd');&quot; /&amp;gt;&lt;br /&gt;						&amp;lt;/td&amp;gt;&lt;br /&gt;					&amp;lt;/tr&amp;gt;&lt;br /&gt;					&amp;lt;tr&amp;gt;&lt;br /&gt;						&amp;lt;td width=&quot;20%&quot; class=&quot;key&quot;&amp;gt;&lt;br /&gt;							&amp;lt;label for=&quot;published&quot;&amp;gt;Published&amp;lt;/label&amp;gt;&lt;br /&gt;						&amp;lt;/td&amp;gt;&lt;br /&gt;						&amp;lt;td&amp;gt;&lt;br /&gt;							&amp;lt;?php echo JHTML::_('select.booleanlist',  'published', '', $row-&amp;gt;published ); ?&amp;gt;&lt;br /&gt;						&amp;lt;/td&amp;gt;&lt;br /&gt;					&amp;lt;/tr&amp;gt;&lt;br /&gt;				&amp;lt;/tbody&amp;gt;&lt;br /&gt;			&amp;lt;/table&amp;gt;&lt;br /&gt;			&amp;lt;/fieldset&amp;gt;&lt;br /&gt;		&amp;lt;/div&amp;gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The edit form uses the 'col100', 'adminform', 'admintable', 'key', 'button', and 'inputbox' classes to format the output to look like other forms in the Joomla! admin interface. The 'message' and 'date' variables are directly populated with values from the $row object. Next to the date field, we build a form button and assign an onclick event to it that displays our popup calendar when clicked. Since we pass 'date' into this Javascript function, it will look for the input named 'date' and fill it in with is chosen from the popup. The 'published' field is represented as a radio button, which we generate using JTHML::_('select.booleanlist', ... ),&lt;/p&gt;
&lt;pre&gt;		&amp;lt;input type=&quot;hidden&quot; name=&quot;option&quot; value=&quot;&amp;lt;?php echo $option; ?&amp;gt;&quot; /&amp;gt;&lt;br /&gt;		&amp;lt;input type=&quot;hidden&quot; name=&quot;task&quot; value=&quot;&quot; /&amp;gt;&lt;br /&gt;		&amp;lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;&amp;lt;?php echo $row-&amp;gt;id ?&amp;gt;&quot; /&amp;gt;&lt;br /&gt;		&amp;lt;/form&amp;gt;&lt;br /&gt;		&amp;lt;?php&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;As with the message list, we need a few hidden variables to take care of a few things. We include the 'option' value and a blank 'task' variable as we did before. We also add an 'id' field which is set to the row id, if it exists. If no value is provided here or it does not exist, our code will assume that it is a new record and will add it to the database.&lt;/p&gt;
&lt;pre&gt;	}&lt;br /&gt;&lt;br /&gt;	function setMessageToolbar($id)&lt;br /&gt;	{&lt;br /&gt;		if ($id) {&lt;br /&gt;			$newEdit = 'Edit';&lt;br /&gt;		} else {&lt;br /&gt;			$newEdit = 'New';&lt;br /&gt;		}&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;We called setMessageToolbar() from our edit() function to configure the toolbar for our editing screen. It takes the row $id as the parameter. We use this to determine if we are adding or editing a message and set $newEdit accordingly.&lt;/p&gt;
&lt;pre&gt;		JToolBarHelper::title($newEdit . ' Message', 'generic.png');&lt;br /&gt;		JToolBarHelper::save();&lt;br /&gt;		JToolBarHelper::cancel();&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The JToolBarHelper member functions add toolbar buttons in the order you call them. The exception to this is the title() function which sets the screen title to the left of the toolbar. Using our $newEdit variable set above, we set this message, then pass in the name of the image we want to use as the icon for the title. After setting the title, we add the 'save' and 'cancel' buttons to the toolbar. When these are clicked, they will set the task variable in the form to 'save' and 'cancel' respectively.&lt;/p&gt;
&lt;pre&gt;	}&lt;br /&gt;&lt;br /&gt;	function setAllMessagesToolbar()&lt;br /&gt;	{&lt;br /&gt;		JToolBarHelper::title('Message Manager', 'generic.png');&lt;br /&gt;		JToolBarHelper::publishList();&lt;br /&gt;		JToolBarHelper::unpublishList();&lt;br /&gt;		JToolBarHelper::deleteList();&lt;br /&gt;		JToolBarHelper::editList();&lt;br /&gt;		JToolBarHelper::addNew();&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Like the toolbar for editing, we set the title first along with an icon. Then we proceed to add buttons for publishing, unpublishing, deleting, editing, and adding, which set task to 'publish', 'unpublish', 'remove', 'edit', and 'add' respectively. The functions names ending in 'List' also check to make sure that at least one of the checkboxes is ticked before submitting the form. Otherwise, a Javascript alert appears.&lt;/p&gt;
&lt;pre&gt;	}&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;tablesdailymessage&quot; class=&quot;dailymessage&quot;&gt;tables/dailymessage.php&lt;/h3&gt;
&lt;div class=&quot;source&quot;&gt;
&lt;pre&gt;&amp;lt;?php&lt;br /&gt;&lt;br /&gt;defined( '_JEXEC' ) or die( 'Restricted access' );&lt;br /&gt;&lt;br /&gt;class TableDailyMessage extends JTable&lt;br /&gt;{&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;We start by checking to make sure that we are inside of Joomla!, then declare the TableDailyMessage class as an extension of the JTable class.&lt;/p&gt;
&lt;pre&gt;	var $id = null;&lt;br /&gt;	var $message = null;&lt;br /&gt;	var $date = null;&lt;br /&gt;	var $published = null;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;These four variables match the four columns found in the #__dailymessage table in the database. We begin by setting them to null. This makes it easier for the class to generate SQL UPDATE commands: it can skip over any variable that is still set to null.&lt;/p&gt;
&lt;pre&gt;	function __construct(&amp;amp;$db)&lt;br /&gt;	{&lt;br /&gt;		parent::__construct( '#__dailymessage', 'id', $db );&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The only method we are defining for TableDailyMessage is __construct(). This is PHP 5's constructor which is emulated under PHP 4 (if you are still running that version). The current database object gets passed in by reference. Right away, we call JTable's original constructor and pass in the name of our table (with the #__ prefix shorthand), the name of the key column, and the database object. Since we have identified the 'id' column as the key, the object will know when to generate UPDATE rather than INSERT statements based on whether 'id' is set. It will also use this key when we call the load() or delete() functions.&lt;/p&gt;
&lt;pre&gt;		jimport('joomla.utilities.date');&lt;br /&gt;		$now = new JDate();&lt;br /&gt;		$this-&amp;gt;set( 'date', $now-&amp;gt;toMySQL() );&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;We also want to set the current date as the default value for 'date' in the event that none is specified. First, we call jimport() to pull in the date utilities, then create a date object and store it in $now. (This object defaults to the current date and time.) Then we call JTable's set() member function, passing in 'date' (the column we wish to set) and then the date we wish to set it to. The toMySQL() member function of the JDate class takes the date represented in the object and returns a MySQL-formatted copy.&lt;/p&gt;
&lt;pre&gt;	}&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;dailymessagexml&quot; class=&quot;dailymessage&quot;&gt;dailymessage.xml&lt;/h3&gt;
&lt;div class=&quot;source&quot;&gt;
&lt;pre&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&lt;br /&gt;&amp;lt;install type=&quot;component&quot; version=&quot;1.5.0&quot;&amp;gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;This XML file serves three purposes: identifying our component, guiding the component installation/removal, and providing the configuration parameters that are available when we create a menu link to the component. The first line of this file identifies it as an XML 1.0 document in UTF-8 format. We continue with an opening &amp;lt;install&amp;gt; tag that encloses the rest of the file. We identify the package type as a component and designate that it is intended for Joomla! 1.5.0.&lt;/p&gt;
&lt;pre&gt;	&amp;lt;name&amp;gt;Daily Message&amp;lt;/name&amp;gt;&lt;br /&gt;	&amp;lt;author&amp;gt;Joseph LeBlanc&amp;lt;/author&amp;gt;&lt;br /&gt;	&amp;lt;creationDate&amp;gt;August 2007&amp;lt;/creationDate&amp;gt;&lt;br /&gt;	&amp;lt;copyright&amp;gt;(C) 2004 - 2007 Joseph L. LeBlanc. All rights reserved.&amp;lt;/copyright&amp;gt;&lt;br /&gt;	&amp;lt;license&amp;gt;http://www.opensource.org/licenses/mit-license.php MIT&amp;lt;/license&amp;gt;&lt;br /&gt;	&amp;lt;authorEmail&amp;gt;contact@jlleblanc.com&amp;lt;/authorEmail&amp;gt;&lt;br /&gt;	&amp;lt;authorUrl&amp;gt;www.jlleblanc.com&amp;lt;/authorUrl&amp;gt;&lt;br /&gt;	&amp;lt;version&amp;gt;1.5.0&amp;lt;/version&amp;gt;&lt;br /&gt;	&amp;lt;description&amp;gt;Manages message for dates&amp;lt;/description&amp;gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The &amp;lt;name&amp;gt;, &amp;lt;author&amp;gt;, &amp;lt;creationDate&amp;gt;, &amp;lt;copyright&amp;gt;, &amp;lt;license&amp;gt;, &amp;lt;authorEmail&amp;gt;, &amp;lt;authorUrl&amp;gt;, &amp;lt;version&amp;gt;, and &amp;lt;description&amp;gt; elements are all used to identify the component within Joomla!. Although in this case the &amp;lt;version&amp;gt; element matches the version attribute on the &amp;lt;install&amp;gt; tag, this element is intended to identify the version of your component (rather than the target Joomla! version).&lt;/p&gt;
&lt;pre&gt;	&amp;lt;install&amp;gt;&lt;br /&gt;		&amp;lt;sql&amp;gt;&lt;br /&gt;			&amp;lt;file driver=&quot;mysql&quot; charset=&quot;utf8&quot;&amp;gt;install.mysql.sql&amp;lt;/file&amp;gt;&lt;br /&gt;		&amp;lt;/sql&amp;gt;&lt;br /&gt;	&amp;lt;/install&amp;gt;&lt;br /&gt;&lt;br /&gt;	&amp;lt;uninstall&amp;gt;&lt;br /&gt;		&amp;lt;sql&amp;gt;&lt;br /&gt;			&amp;lt;file driver=&quot;mysql&quot; charset=&quot;utf8&quot;&amp;gt;uninstall.mysql.sql&amp;lt;/file&amp;gt;&lt;br /&gt;		&amp;lt;/sql&amp;gt;&lt;br /&gt;	&amp;lt;/uninstall&amp;gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;These tags identify the SQL files to run when installing and uninstalling the component. Joomla! is designed to support multiple database types. If you want to support other databases in addition to MySQL, you will need to add separate SQL files to these sections.&lt;/p&gt;
&lt;pre&gt;	&amp;lt;files&amp;gt;&lt;br /&gt;		&amp;lt;filename&amp;gt;dailymessage.php&amp;lt;/filename&amp;gt;&lt;br /&gt;	&amp;lt;/files&amp;gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;This section identifies all of the files going into the frontend portion (/components/com_dailymessage) of the component. Daily Message has a very simple frontend, so only dailymessage.php is included.&lt;/p&gt;
&lt;pre&gt;	&amp;lt;params&amp;gt;&lt;br /&gt;		&amp;lt;param name=&quot;bold&quot; type=&quot;radio&quot; default=&quot;0&quot; label=&quot;Bold&quot; description=&quot;Display messages in bold&quot;&amp;gt;&lt;br /&gt;			&amp;lt;option value=&quot;0&quot;&amp;gt;No&amp;lt;/option&amp;gt;&lt;br /&gt;			&amp;lt;option value=&quot;1&quot;&amp;gt;Yes&amp;lt;/option&amp;gt;&lt;br /&gt;		&amp;lt;/param&amp;gt;&lt;br /&gt;		&amp;lt;param name=&quot;italic&quot; type=&quot;radio&quot; default=&quot;0&quot; label=&quot;Italic&quot; description=&quot;Display messages in italics&quot;&amp;gt;&lt;br /&gt;			&amp;lt;option value=&quot;0&quot;&amp;gt;No&amp;lt;/option&amp;gt;&lt;br /&gt;			&amp;lt;option value=&quot;1&quot;&amp;gt;Yes&amp;lt;/option&amp;gt;&lt;br /&gt;		&amp;lt;/param&amp;gt;&lt;br /&gt;		&amp;lt;param name=&quot;underline&quot; type=&quot;radio&quot; default=&quot;0&quot; label=&quot;Underline&quot; description=&quot;Display messages with an underline&quot;&amp;gt;&lt;br /&gt;			&amp;lt;option value=&quot;0&quot;&amp;gt;No&amp;lt;/option&amp;gt;&lt;br /&gt;			&amp;lt;option value=&quot;1&quot;&amp;gt;Yes&amp;lt;/option&amp;gt;&lt;br /&gt;		&amp;lt;/param&amp;gt;&lt;br /&gt;	&amp;lt;/params&amp;gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;When we create a frontend link to the Daily Message component, we want to do some quick configuration. These &amp;lt;param&amp;gt; tags allow us to provide several options. On the link editing screen, these tags will be read and HTML elements will automatically be generated based on them. When the administrator saves the link, the values chosen will be saved along with the menu item; there is no need to create another table or any other place to store this information.&lt;/p&gt;
&lt;pre&gt;	&amp;lt;administration&amp;gt;&lt;br /&gt;		&amp;lt;menu&amp;gt;Daily Message&amp;lt;/menu&amp;gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;Some of the elements of our component are distinctly a part of the backend and should never reach the frontend. We put these within the &amp;lt;administration&amp;gt; tags. To begin, we add a &amp;lt;menu&amp;gt; tag defining the name of the item added to the Components menu. This will give administrators a link to the list screen in backend of the component.&lt;/p&gt;
&lt;pre&gt;		&amp;lt;files folder=&quot;admin&quot;&amp;gt;&lt;br /&gt;			&amp;lt;filename&amp;gt;install.mysql.sql&amp;lt;/filename&amp;gt;&lt;br /&gt;			&amp;lt;filename&amp;gt;uninstall.mysql.sql&amp;lt;/filename&amp;gt;&lt;br /&gt;			&amp;lt;filename&amp;gt;admin.dailymessage.php&amp;lt;/filename&amp;gt;&lt;br /&gt;			&amp;lt;filename&amp;gt;admin.dailymessage.html.php&amp;lt;/filename&amp;gt;&lt;br /&gt;			&amp;lt;filename&amp;gt;controller.php&amp;lt;/filename&amp;gt;&lt;br /&gt;			&amp;lt;filename&amp;gt;LICENSE&amp;lt;/filename&amp;gt;&lt;br /&gt;			&amp;lt;filename&amp;gt;tables/dailymessage.php&amp;lt;/filename&amp;gt;&lt;br /&gt;		&amp;lt;/files&amp;gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;The &amp;lt;files&amp;gt; tag encloses a list of files to be copied to /administrator/components/com_dailymessage. Within our .zip file, there is a folder named 'admin' where all of these files are kept. Notice that we are again listing install.mysql.sql and uninstall.mysql.sql: if we do not do this, these files will not be copied and will not get executed. Also, when we list files under subdirectores (like tables/dailymessage.php), these subdirectories will automatically be created under /administrator/components/com_dailymessage.&lt;/p&gt;
&lt;pre&gt;	&amp;lt;/administration&amp;gt;&lt;br /&gt;&lt;br /&gt;&amp;lt;/install&amp;gt;&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;These two closing tags finish off the file.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a class=&quot;online&quot; href=&quot;http://jlleblanc.com/com_dailymessage15.zip&quot;&gt;Download a copy of the component here.&lt;/a&gt;&lt;/p&gt;</content>
	</entry>
	<entry>
		<title>Writing Joomla! Extensions</title>
		<link rel="alternate" type="text/html" href="http://jlleblanc.com/tutorials/45-writing-joomla-extensions"/>
		<published>2007-03-26T08:16:45Z</published>
		<updated>2007-03-26T08:16:45Z</updated>
		<id>http://jlleblanc.com/tutorials/45-writing-joomla-extensions</id>
		<summary type="html">Here's a &lt;a href=&quot;http://jlleblanc.com/joomlaextensions.ppt&quot;&gt;copy of the PowerPoint&lt;/a&gt; I used for my presentation at &lt;a href=&quot;http://2007.oscms-summit.org/&quot;&gt;OSCMS&lt;/a&gt;. I'll publish a full copy of Daily Message 1.5 when I get a chance to finish it. &lt;br /&gt;&lt;br /&gt;</summary>
		<content type="html">Here's a &lt;a href=&quot;http://jlleblanc.com/joomlaextensions.ppt&quot;&gt;copy of the PowerPoint&lt;/a&gt; I used for my presentation at &lt;a href=&quot;http://2007.oscms-summit.org/&quot;&gt;OSCMS&lt;/a&gt;. I'll publish a full copy of Daily Message 1.5 when I get a chance to finish it. &lt;br /&gt;&lt;br /&gt;</content>
	</entry>
	<entry>
		<title>Daily Message Update</title>
		<link rel="alternate" type="text/html" href="http://jlleblanc.com/tutorials/35-daily-message-update"/>
		<published>2005-10-04T20:29:16Z</published>
		<updated>2005-10-04T20:29:16Z</updated>
		<id>http://jlleblanc.com/tutorials/35-daily-message-update</id>
		<summary type="html">In the midst of preparing for a presentation on component development,
I found a small anomaly in the Daily Message component. In the older
versions, I've put the dailymessage.class.php file in the backend
folder (administrator/components/com_dailymessage/). However, this can
cause permission problems with more complicated components if you are
trying to keep frontend code from accessing any part of the backend.
Fortunately, it appears that the call to $mainframe-&amp;gt;getPath(
'class' ) will find the file regardless of whether it is in the
frontend or back. You can download the updated version &lt;a target=&quot;_self&quot; mce_real_href=&quot;http://jlleblanc.com/com_dailymessage.zip&quot; href=&quot;http://jlleblanc.com/com_dailymessage.zip&quot;&gt;here&lt;/a&gt; .&lt;br /&gt;
</summary>
		<content type="html">In the midst of preparing for a presentation on component development,
I found a small anomaly in the Daily Message component. In the older
versions, I've put the dailymessage.class.php file in the backend
folder (administrator/components/com_dailymessage/). However, this can
cause permission problems with more complicated components if you are
trying to keep frontend code from accessing any part of the backend.
Fortunately, it appears that the call to $mainframe-&amp;gt;getPath(
'class' ) will find the file regardless of whether it is in the
frontend or back. You can download the updated version &lt;a target=&quot;_self&quot; mce_real_href=&quot;http://jlleblanc.com/com_dailymessage.zip&quot; href=&quot;http://jlleblanc.com/com_dailymessage.zip&quot;&gt;here&lt;/a&gt; .&lt;br /&gt;
</content>
	</entry>
	<entry>
		<title>Bare Minimum Joomla Component</title>
		<link rel="alternate" type="text/html" href="http://jlleblanc.com/tutorials/25-bare-minimum-joomla-component"/>
		<published>2005-04-27T11:33:04Z</published>
		<updated>2005-04-27T11:33:04Z</updated>
		<id>http://jlleblanc.com/tutorials/25-bare-minimum-joomla-component</id>
		<summary type="html">
By popular demand, here is the Bare Minimum component. This component
has no parameters, database queries, external classes, or superfluous
installation files.&lt;br /&gt;</summary>
		<content type="html">
By popular demand, here is the Bare Minimum component. This component
has no parameters, database queries, external classes, or superfluous
installation files.&lt;br /&gt;</content>
	</entry>
	<entry>
		<title>Add To My Yahoo Module and Tutorial</title>
		<link rel="alternate" type="text/html" href="http://jlleblanc.com/tutorials/23-add-to-my-yahoo-module-and-tutorial"/>
		<published>2005-03-15T13:53:46Z</published>
		<updated>2005-03-15T13:53:46Z</updated>
		<id>http://jlleblanc.com/tutorials/23-add-to-my-yahoo-module-and-tutorial</id>
		<summary type="html">Do you syndicate your site using RSS? If so, install the Add to My Yahoo! module. This allows your visitors to add your article headlines to their My Yahoo! start pages, without having to configure a newsreader.</summary>
		<content type="html">Do you syndicate your site using RSS? If so, install the Add to My Yahoo! module. This allows your visitors to add your article headlines to their My Yahoo! start pages, without having to configure a newsreader.</content>
	</entry>
	<entry>
		<title>Daily Message with E-mail</title>
		<link rel="alternate" type="text/html" href="http://jlleblanc.com/tutorials/22-daily-message-with-e-mail"/>
		<published>2005-03-10T22:43:35Z</published>
		<updated>2005-03-10T22:43:35Z</updated>
		<id>http://jlleblanc.com/tutorials/22-daily-message-with-e-mail</id>
		<summary type="html">You can easily give your visitors the ability to send their friends Daily Messages through e-mail. Using the mosMail() function, you ensure the appropriate settings are in place and do not have to wrestle with message headers. You can also place this in a styled pop-up window without loading the full template.</summary>
		<content type="html">You can easily give your visitors the ability to send their friends Daily Messages through e-mail. Using the mosMail() function, you ensure the appropriate settings are in place and do not have to wrestle with message headers. You can also place this in a styled pop-up window without loading the full template.</content>
	</entry>
	<entry>
		<title>Daily Message with HTML editors &amp; Dates</title>
		<link rel="alternate" type="text/html" href="http://jlleblanc.com/tutorials/21-daily-message-with-html-editors-a-dates"/>
		<published>2005-02-26T00:02:35Z</published>
		<updated>2005-02-26T00:02:35Z</updated>
		<id>http://jlleblanc.com/tutorials/21-daily-message-with-html-editors-a-dates</id>
		<summary type="html">
&lt;span style=&quot;font-family: verdana,arial,helvetica,sans-serif;&quot;&gt;
Want your component's interface to blend effortlessly with the rest of Joomla? The core developers have made it quite easy. With a few short lines of code, your component can utilize editors and the built-in calendar. When you do call these elements, they match the preferences already set by the administrator, which reduces the learning curve for users.&lt;/span&gt;</summary>
		<content type="html">
&lt;span style=&quot;font-family: verdana,arial,helvetica,sans-serif;&quot;&gt;
Want your component's interface to blend effortlessly with the rest of Joomla? The core developers have made it quite easy. With a few short lines of code, your component can utilize editors and the built-in calendar. When you do call these elements, they match the preferences already set by the administrator, which reduces the learning curve for users.&lt;/span&gt;</content>
	</entry>
	<entry>
		<title>Joomla Daily Message Module Tutorial</title>
		<link rel="alternate" type="text/html" href="http://jlleblanc.com/tutorials/13-daily-message-module-tutorial"/>
		<published>2004-11-03T15:48:49Z</published>
		<updated>2004-11-03T15:48:49Z</updated>
		<id>http://jlleblanc.com/tutorials/13-daily-message-module-tutorial</id>
		<summary type="html">
One of the simplest ways of integrating an
existing program into a new Joomla installation is through the
construction of a module. If you are unsure of whether to build a
component or a module, read &lt;a href=&quot;http://jlleblanc.com/index.php?option=com_content&amp;task=view&amp;id=11&amp;Itemid=52&quot;&gt;The Difference Between Components and Modules&lt;/a&gt;. Modules are typically well suited for smaller features (news headlines, polls, etc...) to complement the main body of content.&lt;br /&gt;&lt;br /&gt;This tutorial is an extension of the &lt;a href=&quot;http://jlleblanc.com/index.php?option=com_content&amp;task=view&amp;id=9&amp;Itemid=54&quot; class=&quot;ext&quot;&gt;Daily Message Component Tutorial&lt;/a&gt;.
To use this module successfully, it is necessary to install the Daily
Message component. Although this module is designed to work in
conjunction with a component, other modules may be developed
independently of a component.&lt;br /&gt;</summary>
		<content type="html">
One of the simplest ways of integrating an
existing program into a new Joomla installation is through the
construction of a module. If you are unsure of whether to build a
component or a module, read &lt;a href=&quot;http://jlleblanc.com/index.php?option=com_content&amp;task=view&amp;id=11&amp;Itemid=52&quot;&gt;The Difference Between Components and Modules&lt;/a&gt;. Modules are typically well suited for smaller features (news headlines, polls, etc...) to complement the main body of content.&lt;br /&gt;&lt;br /&gt;This tutorial is an extension of the &lt;a href=&quot;http://jlleblanc.com/index.php?option=com_content&amp;task=view&amp;id=9&amp;Itemid=54&quot; class=&quot;ext&quot;&gt;Daily Message Component Tutorial&lt;/a&gt;.
To use this module successfully, it is necessary to install the Daily
Message component. Although this module is designed to work in
conjunction with a component, other modules may be developed
independently of a component.&lt;br /&gt;</content>
	</entry>
	<entry>
		<title>Joomla Component Tabbed Interface For Backend</title>
		<link rel="alternate" type="text/html" href="http://jlleblanc.com/tutorials/12-tabbed-interface-for-backend"/>
		<published>2004-08-21T16:41:14Z</published>
		<updated>2004-08-21T16:41:14Z</updated>
		<id>http://jlleblanc.com/tutorials/12-tabbed-interface-for-backend</id>
		<summary type="html">Many popular Joomla components have tabbed interfaces for the administrative backend, providing logical divisions for otherwise large forms. The code for these tabs are a part of the Joomla core, ready and waiting to be a part of your next project!</summary>
		<content type="html">Many popular Joomla components have tabbed interfaces for the administrative backend, providing logical divisions for otherwise large forms. The code for these tabs are a part of the Joomla core, ready and waiting to be a part of your next project!</content>
	</entry>
</feed>
